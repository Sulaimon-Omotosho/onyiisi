"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiffError: () => (/* binding */ DiffError),\n/* harmony export */   diffItem: () => (/* binding */ diffItem),\n/* harmony export */   diffPatch: () => (/* binding */ diffPatch)\n/* harmony export */ });\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\nfunction pathToString(path) {\n  return path.reduce((target, segment, i) => {\n    if (Array.isArray(segment)) {\n      return \"\".concat(target, \"[\").concat(segment.join(\":\"), \"]\");\n    }\n    if (isKeyedObject(segment)) {\n      return \"\".concat(target, \"[_key==\\\"\").concat(segment._key, \"\\\"]\");\n    }\n    if (typeof segment === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    } else if (typeof segment === \"string\" && /^\\d+$/.test(segment)) {\n      return \"\".concat(target, \"[\\\"\").concat(segment, \"\\\"]\");\n    }\n    if (typeof segment === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    throw new Error(\"Unsupported path segment \\\"\".concat(segment, \"\\\"\"));\n  }, \"\");\n}\nfunction isKeyedObject(obj) {\n  return typeof obj === \"object\" && typeof obj._key === \"string\";\n}\nclass DiffError extends Error {\n  constructor(message, path, value) {\n    const serializedPath = pathToString(path);\n    super(\"\".concat(message, \" (at '\").concat(serializedPath, \"')\"));\n    this.path = path;\n    this.serializedPath = serializedPath;\n    this.value = value;\n  }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;\nconst propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n  if (!propStartPattern.test(property)) {\n    throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n  }\n  if (!propPattern.test(property)) {\n    throw new DiffError(\"Keys can only contain letters, numbers and underscores\", path.concat(property), value);\n  }\n  if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n    if (typeof value !== \"string\") {\n      throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n    }\n    if (!idPattern.test(value)) {\n      throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n    }\n  }\n  return property;\n}\nconst ignoredKeys = [\"_id\", \"_type\", \"_createdAt\", \"_updatedAt\", \"_rev\"];\nconst defaultOptions = {\n  hideWarnings: false,\n  diffMatchPatch: {\n    enabled: true,\n    // Only use diff-match-patch if target string is longer than this threshold\n    lengthThresholdAbsolute: 30,\n    // Only use generated diff-match-patch if the patch length is less than or equal to\n    // (targetString * relative). Example: A 100 character target with a relative factor\n    // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n    // it will fall back to a regular `set` patch.\n    lengthThresholdRelative: 1.2\n  }\n};\nfunction mergeOptions(options) {\n  return {\n    ...defaultOptions,\n    ...options,\n    diffMatchPatch: {\n      ...defaultOptions.diffMatchPatch,\n      ...(options.diffMatchPatch || {})\n    }\n  };\n}\nfunction diffPatch(itemA, itemB, opts) {\n  const options = mergeOptions(opts || {});\n  const id = options.id || itemA._id === itemB._id && itemA._id;\n  const revisionLocked = options.ifRevisionID;\n  const ifRevisionID = typeof revisionLocked === \"boolean\" ? itemA._rev : revisionLocked;\n  const basePath = options.basePath || [];\n  if (!id) {\n    throw new Error(\"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\");\n  }\n  if (revisionLocked === true && !ifRevisionID) {\n    throw new Error(\"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\");\n  }\n  if (basePath.length === 0 && itemA._type !== itemB._type) {\n    throw new Error(\"_type is immutable and cannot be changed (\".concat(itemA._type, \" => \").concat(itemB._type, \")\"));\n  }\n  const operations = diffItem(itemA, itemB, options, basePath, []);\n  return serializePatches(operations, {\n    id,\n    ifRevisionID: revisionLocked ? ifRevisionID : void 0\n  });\n}\nfunction diffItem(itemA, itemB) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let patches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  if (itemA === itemB) {\n    return patches;\n  }\n  const aType = Array.isArray(itemA) ? \"array\" : typeof itemA;\n  const bType = Array.isArray(itemB) ? \"array\" : typeof itemB;\n  const aIsUndefined = aType === \"undefined\";\n  const bIsUndefined = bType === \"undefined\";\n  if (aIsUndefined && !bIsUndefined) {\n    patches.push({\n      op: \"set\",\n      path,\n      value: itemB\n    });\n    return patches;\n  }\n  if (!aIsUndefined && bIsUndefined) {\n    patches.push({\n      op: \"unset\",\n      path\n    });\n    return patches;\n  }\n  const options = mergeOptions(opts);\n  const dataType = aIsUndefined ? bType : aType;\n  const isContainer = dataType === \"object\" || dataType === \"array\";\n  if (!isContainer) {\n    return diffPrimitive(itemA, itemB, options, path, patches);\n  }\n  if (aType !== bType) {\n    patches.push({\n      op: \"set\",\n      path,\n      value: itemB\n    });\n    return patches;\n  }\n  return dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n  const atRoot = path.length === 0;\n  const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemA[key], path));\n  const aKeysLength = aKeys.length;\n  const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map(key => validateProperty(key, itemB[key], path));\n  const bKeysLength = bKeys.length;\n  for (let i = 0; i < aKeysLength; i++) {\n    const key = aKeys[i];\n    if (!(key in itemB)) {\n      patches.push({\n        op: \"unset\",\n        path: path.concat(key)\n      });\n    }\n  }\n  for (let i = 0; i < bKeysLength; i++) {\n    const key = bKeys[i];\n    diffItem(itemA[key], itemB[key], options, path.concat([key]), patches);\n  }\n  return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n  if (itemB.length > itemA.length) {\n    patches.push({\n      op: \"insert\",\n      after: path.concat([-1]),\n      items: itemB.slice(itemA.length).map((item, i) => nullifyUndefined(item, path, i, options))\n    });\n  }\n  if (itemB.length < itemA.length) {\n    const isSingle = itemA.length - itemB.length === 1;\n    const unsetItems = itemA.slice(itemB.length);\n    if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {\n      patches.push({\n        op: \"unset\",\n        path: path.concat([isSingle ? itemB.length : [itemB.length, \"\"]])\n      });\n    } else {\n      patches.push(...unsetItems.map(item => ({\n        op: \"unset\",\n        path: path.concat({\n          _key: item._key\n        })\n      })));\n    }\n  }\n  for (let i = 0; i < itemB.length; i++) {\n    if (Array.isArray(itemB[i])) {\n      throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n    }\n  }\n  const overlapping = Math.min(itemA.length, itemB.length);\n  const segmentA = itemA.slice(0, overlapping);\n  const segmentB = itemB.slice(0, overlapping);\n  return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n  for (let i = 0; i < itemA.length; i++) {\n    diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);\n  }\n  return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n  const keyedA = indexByKey(itemA);\n  const keyedB = indexByKey(itemB);\n  if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {\n    return diffArrayByIndex(itemA, itemB, options, path, patches);\n  }\n  for (let i = 0; i < keyedB.keys.length; i++) {\n    const key = keyedB.keys[i];\n    const valueA = keyedA.index[key];\n    const valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n    diffItem(valueA, valueB, options, path.concat({\n      _key: key\n    }), patches);\n  }\n  return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n  const {\n    enabled,\n    lengthThresholdRelative,\n    lengthThresholdAbsolute\n  } = options.diffMatchPatch;\n  const segment = path[path.length - 1];\n  if (!enabled ||\n  // Don't use for anything but strings\n  typeof itemA !== \"string\" || typeof itemB !== \"string\" ||\n  // Don't use for `_key`, `_ref` etc\n  typeof segment === \"string\" && segment[0] === \"_\" ||\n  // Don't use on short strings\n  itemB.length < lengthThresholdAbsolute) {\n    return void 0;\n  }\n  let strPatch = \"\";\n  try {\n    const patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makeDiff)(itemA, itemB);\n    const diff = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.cleanupEfficiency)(patch);\n    strPatch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.stringifyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makePatches)(diff));\n  } catch (err) {\n    return void 0;\n  }\n  return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {\n    op: \"diffMatchPatch\",\n    path,\n    value: strPatch\n  };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n  const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n  patches.push(dmp || {\n    op: \"set\",\n    path,\n    value: itemB\n  });\n  return patches;\n}\nfunction isNotIgnoredKey(key) {\n  return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n  if (patches.length === 0) {\n    return [];\n  }\n  const {\n    id,\n    ifRevisionID\n  } = options;\n  const set = patches.filter(patch => patch.op === \"set\");\n  const unset = patches.filter(patch => patch.op === \"unset\");\n  const insert = patches.filter(patch => patch.op === \"insert\");\n  const dmp = patches.filter(patch => patch.op === \"diffMatchPatch\");\n  const withSet = set.length > 0 && set.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.set[path] = item.value;\n    return patch;\n  }, {\n    id,\n    set: {}\n  });\n  const withUnset = unset.length > 0 && unset.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.unset.push(path);\n    return patch;\n  }, {\n    id,\n    unset: []\n  });\n  const withInsert = insert.reduce((acc, item) => {\n    const after = pathToString(item.after);\n    return acc.concat({\n      id,\n      insert: {\n        after,\n        items: item.items\n      }\n    });\n  }, []);\n  const withDmp = dmp.length > 0 && dmp.reduce((patch, item) => {\n    const path = pathToString(item.path);\n    patch.diffMatchPatch[path] = item.value;\n    return patch;\n  }, {\n    id,\n    diffMatchPatch: {}\n  });\n  const patchSet = [withSet, withUnset, withDmp, ...withInsert].filter(item => item !== false);\n  return patchSet.map((patch, i) => ({\n    patch: ifRevisionID && i === 0 ? {\n      ...patch,\n      ifRevisionID\n    } : patch\n  }));\n}\nfunction isUniquelyKeyed(arr) {\n  const keys = [];\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i]);\n    if (!key || keys.indexOf(key) !== -1) {\n      return false;\n    }\n    keys.push(key);\n  }\n  return true;\n}\nfunction getKey(obj) {\n  return typeof obj === \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n  return arr.reduce((acc, item) => {\n    acc.keys.push(item._key);\n    acc.index[item._key] = item;\n    return acc;\n  }, {\n    keys: [],\n    index: {}\n  });\n}\nfunction arrayIsEqual(itemA, itemB) {\n  return itemA.length === itemB.length && itemA.every((item, i) => itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n  if (typeof item !== \"undefined\") {\n    return item;\n  }\n  if (!options.hideWarnings) {\n    const serializedPath = pathToString(path.concat(index));\n    console.warn(\"undefined value in array converted to null (at '\".concat(serializedPath, \"')\"));\n  }\n  return null;\n}\nfunction isRevisionLocked(options) {\n  return Boolean(options.ifRevisionID);\n}\nfunction yes(_) {\n  return true;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0VBQVE7QUFDMUIsaUJBQWlCLDJFQUFpQjtBQUNsQyxlQUFlLDBFQUFnQixDQUFDLHFFQUFXO0FBQzNDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBDO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb255aWlzaS8uL25vZGVfbW9kdWxlcy9zYW5pdHktZGlmZi1wYXRjaC9kaXN0L2luZGV4LmpzPzc4NzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFrZURpZmYsIGNsZWFudXBFZmZpY2llbmN5LCBzdHJpbmdpZnlQYXRjaGVzLCBtYWtlUGF0Y2hlcyB9IGZyb20gJ0BzYW5pdHkvZGlmZi1tYXRjaC1wYXRjaCc7XG5mdW5jdGlvbiBwYXRoVG9TdHJpbmcocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHRhcmdldCwgc2VnbWVudCwgaSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0LCBcIltcIikuY29uY2F0KHNlZ21lbnQuam9pbihcIjpcIiksIFwiXVwiKTtcbiAgICB9XG4gICAgaWYgKGlzS2V5ZWRPYmplY3Qoc2VnbWVudCkpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQsIFwiW19rZXk9PVxcXCJcIikuY29uY2F0KHNlZ21lbnQuX2tleSwgXCJcXFwiXVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0LCBcIltcIikuY29uY2F0KHNlZ21lbnQsIFwiXVwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiICYmIC9eXFxkKyQvLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQsIFwiW1xcXCJcIikuY29uY2F0KHNlZ21lbnQsIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3Qgc2VwYXJhdG9yID0gaSA9PT0gMCA/IFwiXCIgOiBcIi5cIjtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQpLmNvbmNhdChzZXBhcmF0b3IpLmNvbmNhdChzZWdtZW50KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcXCJcIi5jb25jYXQoc2VnbWVudCwgXCJcXFwiXCIpKTtcbiAgfSwgXCJcIik7XG59XG5mdW5jdGlvbiBpc0tleWVkT2JqZWN0KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLl9rZXkgPT09IFwic3RyaW5nXCI7XG59XG5jbGFzcyBEaWZmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhdGgsIHZhbHVlKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBhdGggPSBwYXRoVG9TdHJpbmcocGF0aCk7XG4gICAgc3VwZXIoXCJcIi5jb25jYXQobWVzc2FnZSwgXCIgKGF0ICdcIikuY29uY2F0KHNlcmlhbGl6ZWRQYXRoLCBcIicpXCIpKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuc2VyaWFsaXplZFBhdGggPSBzZXJpYWxpemVkUGF0aDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGlkUGF0dGVybiA9IC9eW2EtejAtOV1bYS16MC05Xy4tXSskL2k7XG5jb25zdCBwcm9wUGF0dGVybiA9IC9eW2EtekEtWl9dW2EtekEtWjAtOV9dKiQvO1xuY29uc3QgcHJvcFN0YXJ0UGF0dGVybiA9IC9eW2Etel9dL2k7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgcGF0aCkge1xuICBpZiAoIXByb3BTdGFydFBhdHRlcm4udGVzdChwcm9wZXJ0eSkpIHtcbiAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIgKGEteilcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gIH1cbiAgaWYgKCFwcm9wUGF0dGVybi50ZXN0KHByb3BlcnR5KSkge1xuICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJLZXlzIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycyBhbmQgdW5kZXJzY29yZXNcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gIH1cbiAgaWYgKHByb3BlcnR5ID09PSBcIl9rZXlcIiB8fCBwcm9wZXJ0eSA9PT0gXCJfcmVmXCIgfHwgcHJvcGVydHkgPT09IFwiX3R5cGVcIikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJLZXlzIG11c3QgYmUgc3RyaW5nc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFpZFBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJJbnZhbGlkIGtleSAtIHVzZSBsZXNzIGV4b3RpYyBjaGFyYWN0ZXJzXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydHk7XG59XG5jb25zdCBpZ25vcmVkS2V5cyA9IFtcIl9pZFwiLCBcIl90eXBlXCIsIFwiX2NyZWF0ZWRBdFwiLCBcIl91cGRhdGVkQXRcIiwgXCJfcmV2XCJdO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhpZGVXYXJuaW5nczogZmFsc2UsXG4gIGRpZmZNYXRjaFBhdGNoOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBPbmx5IHVzZSBkaWZmLW1hdGNoLXBhdGNoIGlmIHRhcmdldCBzdHJpbmcgaXMgbG9uZ2VyIHRoYW4gdGhpcyB0aHJlc2hvbGRcbiAgICBsZW5ndGhUaHJlc2hvbGRBYnNvbHV0ZTogMzAsXG4gICAgLy8gT25seSB1c2UgZ2VuZXJhdGVkIGRpZmYtbWF0Y2gtcGF0Y2ggaWYgdGhlIHBhdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAvLyAodGFyZ2V0U3RyaW5nICogcmVsYXRpdmUpLiBFeGFtcGxlOiBBIDEwMCBjaGFyYWN0ZXIgdGFyZ2V0IHdpdGggYSByZWxhdGl2ZSBmYWN0b3JcbiAgICAvLyBvZiAxLjIgd2lsbCBhbGxvdyBhIDEyMCBjaGFyYWN0ZXIgZGlmZi1tYXRjaC1wYXRjaC4gSWYgbGFyZ2VyIHRoYW4gdGhpcyBudW1iZXIsXG4gICAgLy8gaXQgd2lsbCBmYWxsIGJhY2sgdG8gYSByZWd1bGFyIGBzZXRgIHBhdGNoLlxuICAgIGxlbmd0aFRocmVzaG9sZFJlbGF0aXZlOiAxLjJcbiAgfVxufTtcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBkaWZmTWF0Y2hQYXRjaDoge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMuZGlmZk1hdGNoUGF0Y2gsXG4gICAgICAuLi4ob3B0aW9ucy5kaWZmTWF0Y2hQYXRjaCB8fCB7fSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkaWZmUGF0Y2goaXRlbUEsIGl0ZW1CLCBvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0cyB8fCB7fSk7XG4gIGNvbnN0IGlkID0gb3B0aW9ucy5pZCB8fCBpdGVtQS5faWQgPT09IGl0ZW1CLl9pZCAmJiBpdGVtQS5faWQ7XG4gIGNvbnN0IHJldmlzaW9uTG9ja2VkID0gb3B0aW9ucy5pZlJldmlzaW9uSUQ7XG4gIGNvbnN0IGlmUmV2aXNpb25JRCA9IHR5cGVvZiByZXZpc2lvbkxvY2tlZCA9PT0gXCJib29sZWFuXCIgPyBpdGVtQS5fcmV2IDogcmV2aXNpb25Mb2NrZWQ7XG4gIGNvbnN0IGJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aCB8fCBbXTtcbiAgaWYgKCFpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIl9pZCBvbiBpdGVtQSBhbmQgaXRlbUIgbm90IHByZXNlbnQgb3IgZGlmZmVycywgc3BlY2lmeSBkb2N1bWVudCBpZCB0aGUgbXV0YXRpb25zIHNob3VsZCBiZSBhcHBsaWVkIHRvXCIpO1xuICB9XG4gIGlmIChyZXZpc2lvbkxvY2tlZCA9PT0gdHJ1ZSAmJiAhaWZSZXZpc2lvbklEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGlmUmV2aXNpb25JRGAgaXMgc2V0IHRvIGB0cnVlYCwgYnV0IG5vIGBfcmV2YCB3YXMgcGFzc2VkIGluIGl0ZW0gQS4gRWl0aGVyIGV4cGxpY2l0bHkgc2V0IGBpZlJldmlzaW9uSURgIHRvIGEgcmV2aXNpb24sIG9yIHBhc3MgYF9yZXZgIGFzIHBhcnQgb2YgaXRlbSBBLlwiKTtcbiAgfVxuICBpZiAoYmFzZVBhdGgubGVuZ3RoID09PSAwICYmIGl0ZW1BLl90eXBlICE9PSBpdGVtQi5fdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIl90eXBlIGlzIGltbXV0YWJsZSBhbmQgY2Fubm90IGJlIGNoYW5nZWQgKFwiLmNvbmNhdChpdGVtQS5fdHlwZSwgXCIgPT4gXCIpLmNvbmNhdChpdGVtQi5fdHlwZSwgXCIpXCIpKTtcbiAgfVxuICBjb25zdCBvcGVyYXRpb25zID0gZGlmZkl0ZW0oaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBiYXNlUGF0aCwgW10pO1xuICByZXR1cm4gc2VyaWFsaXplUGF0Y2hlcyhvcGVyYXRpb25zLCB7XG4gICAgaWQsXG4gICAgaWZSZXZpc2lvbklEOiByZXZpc2lvbkxvY2tlZCA/IGlmUmV2aXNpb25JRCA6IHZvaWQgMFxuICB9KTtcbn1cbmZ1bmN0aW9uIGRpZmZJdGVtKGl0ZW1BLCBpdGVtQikge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdE9wdGlvbnM7XG4gIGxldCBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcbiAgbGV0IHBhdGNoZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICBpZiAoaXRlbUEgPT09IGl0ZW1CKSB7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgY29uc3QgYVR5cGUgPSBBcnJheS5pc0FycmF5KGl0ZW1BKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBpdGVtQTtcbiAgY29uc3QgYlR5cGUgPSBBcnJheS5pc0FycmF5KGl0ZW1CKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBpdGVtQjtcbiAgY29uc3QgYUlzVW5kZWZpbmVkID0gYVR5cGUgPT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGJJc1VuZGVmaW5lZCA9IGJUeXBlID09PSBcInVuZGVmaW5lZFwiO1xuICBpZiAoYUlzVW5kZWZpbmVkICYmICFiSXNVbmRlZmluZWQpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwic2V0XCIsXG4gICAgICBwYXRoLFxuICAgICAgdmFsdWU6IGl0ZW1CXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgaWYgKCFhSXNVbmRlZmluZWQgJiYgYklzVW5kZWZpbmVkKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICBwYXRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRzKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBhSXNVbmRlZmluZWQgPyBiVHlwZSA6IGFUeXBlO1xuICBjb25zdCBpc0NvbnRhaW5lciA9IGRhdGFUeXBlID09PSBcIm9iamVjdFwiIHx8IGRhdGFUeXBlID09PSBcImFycmF5XCI7XG4gIGlmICghaXNDb250YWluZXIpIHtcbiAgICByZXR1cm4gZGlmZlByaW1pdGl2ZShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xuICB9XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwic2V0XCIsXG4gICAgICBwYXRoLFxuICAgICAgdmFsdWU6IGl0ZW1CXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgcmV0dXJuIGRhdGFUeXBlID09PSBcImFycmF5XCIgPyBkaWZmQXJyYXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSA6IGRpZmZPYmplY3QoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbn1cbmZ1bmN0aW9uIGRpZmZPYmplY3QoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGF0Um9vdCA9IHBhdGgubGVuZ3RoID09PSAwO1xuICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGl0ZW1BKS5maWx0ZXIoYXRSb290ID8gaXNOb3RJZ25vcmVkS2V5IDogeWVzKS5tYXAoa2V5ID0+IHZhbGlkYXRlUHJvcGVydHkoa2V5LCBpdGVtQVtrZXldLCBwYXRoKSk7XG4gIGNvbnN0IGFLZXlzTGVuZ3RoID0gYUtleXMubGVuZ3RoO1xuICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGl0ZW1CKS5maWx0ZXIoYXRSb290ID8gaXNOb3RJZ25vcmVkS2V5IDogeWVzKS5tYXAoa2V5ID0+IHZhbGlkYXRlUHJvcGVydHkoa2V5LCBpdGVtQltrZXldLCBwYXRoKSk7XG4gIGNvbnN0IGJLZXlzTGVuZ3RoID0gYktleXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBhS2V5c1tpXTtcbiAgICBpZiAoIShrZXkgaW4gaXRlbUIpKSB7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdChrZXkpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gYktleXNbaV07XG4gICAgZGlmZkl0ZW0oaXRlbUFba2V5XSwgaXRlbUJba2V5XSwgb3B0aW9ucywgcGF0aC5jb25jYXQoW2tleV0pLCBwYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGRpZmZBcnJheShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgaWYgKGl0ZW1CLmxlbmd0aCA+IGl0ZW1BLmxlbmd0aCkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJpbnNlcnRcIixcbiAgICAgIGFmdGVyOiBwYXRoLmNvbmNhdChbLTFdKSxcbiAgICAgIGl0ZW1zOiBpdGVtQi5zbGljZShpdGVtQS5sZW5ndGgpLm1hcCgoaXRlbSwgaSkgPT4gbnVsbGlmeVVuZGVmaW5lZChpdGVtLCBwYXRoLCBpLCBvcHRpb25zKSlcbiAgICB9KTtcbiAgfVxuICBpZiAoaXRlbUIubGVuZ3RoIDwgaXRlbUEubGVuZ3RoKSB7XG4gICAgY29uc3QgaXNTaW5nbGUgPSBpdGVtQS5sZW5ndGggLSBpdGVtQi5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgdW5zZXRJdGVtcyA9IGl0ZW1BLnNsaWNlKGl0ZW1CLmxlbmd0aCk7XG4gICAgaWYgKGlzUmV2aXNpb25Mb2NrZWQob3B0aW9ucykgfHwgIWlzVW5pcXVlbHlLZXllZCh1bnNldEl0ZW1zKSkge1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgICAgcGF0aDogcGF0aC5jb25jYXQoW2lzU2luZ2xlID8gaXRlbUIubGVuZ3RoIDogW2l0ZW1CLmxlbmd0aCwgXCJcIl1dKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoZXMucHVzaCguLi51bnNldEl0ZW1zLm1hcChpdGVtID0+ICh7XG4gICAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICAgIHBhdGg6IHBhdGguY29uY2F0KHtcbiAgICAgICAgICBfa2V5OiBpdGVtLl9rZXlcbiAgICAgICAgfSlcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtQltpXSkpIHtcbiAgICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJNdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCBwYXRoLmNvbmNhdChpKSwgaXRlbUJbaV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdmVybGFwcGluZyA9IE1hdGgubWluKGl0ZW1BLmxlbmd0aCwgaXRlbUIubGVuZ3RoKTtcbiAgY29uc3Qgc2VnbWVudEEgPSBpdGVtQS5zbGljZSgwLCBvdmVybGFwcGluZyk7XG4gIGNvbnN0IHNlZ21lbnRCID0gaXRlbUIuc2xpY2UoMCwgb3ZlcmxhcHBpbmcpO1xuICByZXR1cm4gaXNVbmlxdWVseUtleWVkKHNlZ21lbnRBKSAmJiBpc1VuaXF1ZWx5S2V5ZWQoc2VnbWVudEIpID8gZGlmZkFycmF5QnlLZXkoc2VnbWVudEEsIHNlZ21lbnRCLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSA6IGRpZmZBcnJheUJ5SW5kZXgoc2VnbWVudEEsIHNlZ21lbnRCLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbn1cbmZ1bmN0aW9uIGRpZmZBcnJheUJ5SW5kZXgoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUEubGVuZ3RoOyBpKyspIHtcbiAgICBkaWZmSXRlbShpdGVtQVtpXSwgbnVsbGlmeVVuZGVmaW5lZChpdGVtQltpXSwgcGF0aCwgaSwgb3B0aW9ucyksIG9wdGlvbnMsIHBhdGguY29uY2F0KGkpLCBwYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGRpZmZBcnJheUJ5S2V5KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBjb25zdCBrZXllZEEgPSBpbmRleEJ5S2V5KGl0ZW1BKTtcbiAgY29uc3Qga2V5ZWRCID0gaW5kZXhCeUtleShpdGVtQik7XG4gIGlmICghYXJyYXlJc0VxdWFsKGtleWVkQS5rZXlzLCBrZXllZEIua2V5cykpIHtcbiAgICByZXR1cm4gZGlmZkFycmF5QnlJbmRleChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZWRCLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXllZEIua2V5c1tpXTtcbiAgICBjb25zdCB2YWx1ZUEgPSBrZXllZEEuaW5kZXhba2V5XTtcbiAgICBjb25zdCB2YWx1ZUIgPSBudWxsaWZ5VW5kZWZpbmVkKGtleWVkQi5pbmRleFtrZXldLCBwYXRoLCBpLCBvcHRpb25zKTtcbiAgICBkaWZmSXRlbSh2YWx1ZUEsIHZhbHVlQiwgb3B0aW9ucywgcGF0aC5jb25jYXQoe1xuICAgICAgX2tleToga2V5XG4gICAgfSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGlmZk1hdGNoUGF0Y2goaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoKSB7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkLFxuICAgIGxlbmd0aFRocmVzaG9sZFJlbGF0aXZlLFxuICAgIGxlbmd0aFRocmVzaG9sZEFic29sdXRlXG4gIH0gPSBvcHRpb25zLmRpZmZNYXRjaFBhdGNoO1xuICBjb25zdCBzZWdtZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICBpZiAoIWVuYWJsZWQgfHxcbiAgLy8gRG9uJ3QgdXNlIGZvciBhbnl0aGluZyBidXQgc3RyaW5nc1xuICB0eXBlb2YgaXRlbUEgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGl0ZW1CICE9PSBcInN0cmluZ1wiIHx8XG4gIC8vIERvbid0IHVzZSBmb3IgYF9rZXlgLCBgX3JlZmAgZXRjXG4gIHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiICYmIHNlZ21lbnRbMF0gPT09IFwiX1wiIHx8XG4gIC8vIERvbid0IHVzZSBvbiBzaG9ydCBzdHJpbmdzXG4gIGl0ZW1CLmxlbmd0aCA8IGxlbmd0aFRocmVzaG9sZEFic29sdXRlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgc3RyUGF0Y2ggPSBcIlwiO1xuICB0cnkge1xuICAgIGNvbnN0IHBhdGNoID0gbWFrZURpZmYoaXRlbUEsIGl0ZW1CKTtcbiAgICBjb25zdCBkaWZmID0gY2xlYW51cEVmZmljaWVuY3kocGF0Y2gpO1xuICAgIHN0clBhdGNoID0gc3RyaW5naWZ5UGF0Y2hlcyhtYWtlUGF0Y2hlcyhkaWZmKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHN0clBhdGNoLmxlbmd0aCA+IGl0ZW1CLmxlbmd0aCAqIGxlbmd0aFRocmVzaG9sZFJlbGF0aXZlID8gdm9pZCAwIDoge1xuICAgIG9wOiBcImRpZmZNYXRjaFBhdGNoXCIsXG4gICAgcGF0aCxcbiAgICB2YWx1ZTogc3RyUGF0Y2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZQcmltaXRpdmUoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGRtcCA9IGdldERpZmZNYXRjaFBhdGNoKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCk7XG4gIHBhdGNoZXMucHVzaChkbXAgfHwge1xuICAgIG9wOiBcInNldFwiLFxuICAgIHBhdGgsXG4gICAgdmFsdWU6IGl0ZW1CXG4gIH0pO1xuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGlzTm90SWdub3JlZEtleShrZXkpIHtcbiAgcmV0dXJuIGlnbm9yZWRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQYXRjaGVzKHBhdGNoZXMsIG9wdGlvbnMpIHtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBpZlJldmlzaW9uSURcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNldCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcInNldFwiKTtcbiAgY29uc3QgdW5zZXQgPSBwYXRjaGVzLmZpbHRlcihwYXRjaCA9PiBwYXRjaC5vcCA9PT0gXCJ1bnNldFwiKTtcbiAgY29uc3QgaW5zZXJ0ID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwiaW5zZXJ0XCIpO1xuICBjb25zdCBkbXAgPSBwYXRjaGVzLmZpbHRlcihwYXRjaCA9PiBwYXRjaC5vcCA9PT0gXCJkaWZmTWF0Y2hQYXRjaFwiKTtcbiAgY29uc3Qgd2l0aFNldCA9IHNldC5sZW5ndGggPiAwICYmIHNldC5yZWR1Y2UoKHBhdGNoLCBpdGVtKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhUb1N0cmluZyhpdGVtLnBhdGgpO1xuICAgIHBhdGNoLnNldFtwYXRoXSA9IGl0ZW0udmFsdWU7XG4gICAgcmV0dXJuIHBhdGNoO1xuICB9LCB7XG4gICAgaWQsXG4gICAgc2V0OiB7fVxuICB9KTtcbiAgY29uc3Qgd2l0aFVuc2V0ID0gdW5zZXQubGVuZ3RoID4gMCAmJiB1bnNldC5yZWR1Y2UoKHBhdGNoLCBpdGVtKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhUb1N0cmluZyhpdGVtLnBhdGgpO1xuICAgIHBhdGNoLnVuc2V0LnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoO1xuICB9LCB7XG4gICAgaWQsXG4gICAgdW5zZXQ6IFtdXG4gIH0pO1xuICBjb25zdCB3aXRoSW5zZXJ0ID0gaW5zZXJ0LnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgY29uc3QgYWZ0ZXIgPSBwYXRoVG9TdHJpbmcoaXRlbS5hZnRlcik7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoe1xuICAgICAgaWQsXG4gICAgICBpbnNlcnQ6IHtcbiAgICAgICAgYWZ0ZXIsXG4gICAgICAgIGl0ZW1zOiBpdGVtLml0ZW1zXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgd2l0aERtcCA9IGRtcC5sZW5ndGggPiAwICYmIGRtcC5yZWR1Y2UoKHBhdGNoLCBpdGVtKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhUb1N0cmluZyhpdGVtLnBhdGgpO1xuICAgIHBhdGNoLmRpZmZNYXRjaFBhdGNoW3BhdGhdID0gaXRlbS52YWx1ZTtcbiAgICByZXR1cm4gcGF0Y2g7XG4gIH0sIHtcbiAgICBpZCxcbiAgICBkaWZmTWF0Y2hQYXRjaDoge31cbiAgfSk7XG4gIGNvbnN0IHBhdGNoU2V0ID0gW3dpdGhTZXQsIHdpdGhVbnNldCwgd2l0aERtcCwgLi4ud2l0aEluc2VydF0uZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gZmFsc2UpO1xuICByZXR1cm4gcGF0Y2hTZXQubWFwKChwYXRjaCwgaSkgPT4gKHtcbiAgICBwYXRjaDogaWZSZXZpc2lvbklEICYmIGkgPT09IDAgPyB7XG4gICAgICAuLi5wYXRjaCxcbiAgICAgIGlmUmV2aXNpb25JRFxuICAgIH0gOiBwYXRjaFxuICB9KSk7XG59XG5mdW5jdGlvbiBpc1VuaXF1ZWx5S2V5ZWQoYXJyKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXJyW2ldKTtcbiAgICBpZiAoIWtleSB8fCBrZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRLZXkob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiBvYmouX2tleTtcbn1cbmZ1bmN0aW9uIGluZGV4QnlLZXkoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICBhY2Mua2V5cy5wdXNoKGl0ZW0uX2tleSk7XG4gICAgYWNjLmluZGV4W2l0ZW0uX2tleV0gPSBpdGVtO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHtcbiAgICBrZXlzOiBbXSxcbiAgICBpbmRleDoge31cbiAgfSk7XG59XG5mdW5jdGlvbiBhcnJheUlzRXF1YWwoaXRlbUEsIGl0ZW1CKSB7XG4gIHJldHVybiBpdGVtQS5sZW5ndGggPT09IGl0ZW1CLmxlbmd0aCAmJiBpdGVtQS5ldmVyeSgoaXRlbSwgaSkgPT4gaXRlbUJbaV0gPT09IGl0ZW0pO1xufVxuZnVuY3Rpb24gbnVsbGlmeVVuZGVmaW5lZChpdGVtLCBwYXRoLCBpbmRleCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGl0ZW0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuaGlkZVdhcm5pbmdzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBhdGggPSBwYXRoVG9TdHJpbmcocGF0aC5jb25jYXQoaW5kZXgpKTtcbiAgICBjb25zb2xlLndhcm4oXCJ1bmRlZmluZWQgdmFsdWUgaW4gYXJyYXkgY29udmVydGVkIHRvIG51bGwgKGF0ICdcIi5jb25jYXQoc2VyaWFsaXplZFBhdGgsIFwiJylcIikpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNSZXZpc2lvbkxvY2tlZChvcHRpb25zKSB7XG4gIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaWZSZXZpc2lvbklEKTtcbn1cbmZ1bmN0aW9uIHllcyhfKSB7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHsgRGlmZkVycm9yLCBkaWZmSXRlbSwgZGlmZlBhdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.js\n");

/***/ })

};
;