"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nvar __defProp$5 = Object.defineProperty, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$5 = (obj, key, value) => (__defNormalProp$5(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\"))\n    part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  constructor(pattern) {\n    __publicField$5(this, \"pattern\"), __publicField$5(this, \"patternRe\"), this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nvar __defProp$4 = Object.defineProperty, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$4 = (obj, key, value) => (__defNormalProp$4(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass StreamValue {\n  constructor(generator) {\n    __publicField$4(this, \"type\", \"stream\"), __publicField$4(this, \"generator\"), __publicField$4(this, \"ticker\"), __publicField$4(this, \"isDone\"), __publicField$4(this, \"data\"), this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return !0;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this)\n      result.push(await value.get());\n    return result;\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for (; ; ) {\n      for (; i < this.data.length; i++)\n        yield this.data[i];\n      if (this.isDone)\n        return;\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker)\n      return this.ticker;\n    let currentResolver;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve;\n      });\n    }, tick = () => {\n      currentResolver(), setupTicker();\n    }, fetch = async () => {\n      for await (const value of this.generator())\n        this.data.push(value), tick();\n      this.isDone = !0, tick();\n    };\n    return setupTicker(), fetch(), this.ticker;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  for (; str.length < targetLength; )\n    str = `0${str}`;\n  return str;\n}\nvar __defProp$3 = Object.defineProperty, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$3 = (obj, key, value) => (__defNormalProp$3(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass StaticValue {\n  constructor(data, type) {\n    __publicField$3(this, \"data\"), __publicField$3(this, \"type\"), this.data = data, this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data))\n      return function* (data) {\n        for (const element of data)\n          yield fromJS(element);\n      }(this.data);\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n  constructor(date) {\n    __publicField$3(this, \"date\"), this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next == \"function\";\n}\nfunction fromJS(val) {\n  return isIterator(val) ? new StreamValue(async function* () {\n    for await (const value of val)\n      yield fromJS(value);\n  }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n  return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nfunction isEqual(a, b) {\n  return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g, MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n  return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text) {\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n  return matchPatternRegex(text).map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text) {\n  return (text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\")}$`, \"i\")\n  );\n}\nasync function gatherText(value, cb) {\n  if (value.type === \"string\")\n    return cb(value.data), !0;\n  if (value.isArray()) {\n    let success = !0;\n    for await (const part of value)\n      part.type === \"string\" ? cb(part.data) : success = !1;\n    return success;\n  }\n  return !1;\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a), bType = getType(b);\n  if (aType !== bType)\n    return null;\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      return a < b ? -1 : a > b ? 1 : 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder)\n    return aTypeOrder - bTypeOrder;\n  let result = partialCompare(a, b);\n  return result === null && (result = 0), result;\n}\nconst operators = {\n  \"==\": function(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\")\n      return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: async function(left, right) {\n    if (right.type === \"path\")\n      return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    if (right.isArray()) {\n      for await (const b of right)\n        if (isEqual(left, b))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    }\n    return NULL_VALUE;\n  },\n  match: async function(left, right) {\n    let tokens = [], patterns = [];\n    return await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part));\n    }), await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part));\n    }) && matchText(tokens, patterns) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"+\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({ ...left.data, ...right.data }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function* () {\n      for await (const val of left)\n        yield val;\n      for await (const val of right)\n        yield val;\n    }) : NULL_VALUE;\n  },\n  \"-\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nvar __defProp$2 = Object.defineProperty, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$2 = (obj, key, value) => (__defNormalProp$2(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass Scope {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    __publicField$2(this, \"params\"), __publicField$2(this, \"source\"), __publicField$2(this, \"value\"), __publicField$2(this, \"parent\"), __publicField$2(this, \"context\"), __publicField$2(this, \"isHidden\", !1), this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n}\nfunction evaluate(node, scope, execute = evaluate) {\n  const func = EXECUTORS[node.type];\n  return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n  return \"then\" in value ? value.then(cb) : cb(value);\n}\nconst EXECUTORS = {\n  This(_, scope) {\n    return scope.value;\n  },\n  Selector() {\n    throw new Error(\"Selectors can not be evaluated\");\n  },\n  Everything(_, scope) {\n    return scope.source;\n  },\n  Parameter({ name }, scope) {\n    return fromJS(scope.params[name]);\n  },\n  Context({ key }, scope) {\n    if (key === \"before\" || key === \"after\")\n      return scope.context[key] || NULL_VALUE;\n    throw new Error(`unknown context key: ${key}`);\n  },\n  Parent({ n }, scope) {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent)\n        return NULL_VALUE;\n      current = current.parent;\n    }\n    return current.value;\n  },\n  OpCall({ op, left, right }, scope, execute) {\n    const func = operators[op];\n    if (!func)\n      throw new Error(`Unknown operator: ${op}`);\n    const leftValue = execute(left, scope), rightValue = execute(right, scope);\n    return \"then\" in leftValue || \"then\" in rightValue ? (async () => func(await leftValue, await rightValue))() : func(leftValue, rightValue);\n  },\n  async Select({ alternatives, fallback }, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope);\n      if (altCond.type === \"boolean\" && altCond.data === !0)\n        return execute(alt.value, scope);\n    }\n    return fallback ? execute(fallback, scope) : NULL_VALUE;\n  },\n  async InRange({ base, left, right, isInclusive }, scope, execute) {\n    const value = await execute(base, scope), leftValue = await execute(left, scope), rightValue = await execute(right, scope), leftCmp = partialCompare(await value.get(), await leftValue.get());\n    if (leftCmp === null)\n      return NULL_VALUE;\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\n    return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  async Filter({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return baseValue.isArray() ? new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem), exprValue = await execute(expr, newScope);\n        exprValue.type === \"boolean\" && exprValue.data === !0 && (yield elem);\n      }\n    }) : NULL_VALUE;\n  },\n  async Projection({ base, expr }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (baseValue.type !== \"object\")\n      return NULL_VALUE;\n    const newScope = scope.createNested(baseValue);\n    return execute(expr, newScope);\n  },\n  FuncCall({ func, args }, scope, execute) {\n    return func(args, scope, execute);\n  },\n  async PipeFuncCall({ func, base, args }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    return func(baseValue, args, scope, execute);\n  },\n  async AccessAttribute({ base, name }, scope, execute) {\n    let value = scope.value;\n    return base && (value = await execute(base, scope)), value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE;\n  },\n  async AccessElement({ base, index }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray())\n      return NULL_VALUE;\n    const data = await baseValue.get(), finalIndex = index < 0 ? index + data.length : index;\n    return fromJS(data[finalIndex]);\n  },\n  async Slice({ base, left, right, isInclusive }, scope, execute) {\n    const baseValue = await execute(base, scope);\n    if (!baseValue.isArray())\n      return NULL_VALUE;\n    const array2 = await baseValue.get();\n    let leftIdx = left, rightIdx = right;\n    return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromJS(array2.slice(leftIdx, rightIdx));\n  },\n  async Deref({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    if (!scope.source.isArray() || value.type !== \"object\")\n      return NULL_VALUE;\n    const id = value.data._ref;\n    if (typeof id != \"string\")\n      return NULL_VALUE;\n    if (scope.context.dereference)\n      return fromJS(await scope.context.dereference({ _ref: id }));\n    for await (const doc of scope.source)\n      if (doc.type === \"object\" && id === doc.data._id)\n        return doc;\n    return NULL_VALUE;\n  },\n  Value({ value }) {\n    return fromJS(value);\n  },\n  Group({ base }, scope, execute) {\n    return execute(base, scope);\n  },\n  async Object({ attributes }, scope, execute) {\n    const result = {};\n    for (const attr of attributes) {\n      const attrType = attr.type;\n      switch (attr.type) {\n        case \"ObjectAttributeValue\": {\n          const value = await execute(attr.value, scope);\n          result[attr.name] = await value.get();\n          break;\n        }\n        case \"ObjectConditionalSplat\": {\n          const cond = await execute(attr.condition, scope);\n          if (cond.type !== \"boolean\" || cond.data === !1)\n            continue;\n          const value = await execute(attr.value, scope);\n          value.type === \"object\" && Object.assign(result, value.data);\n          break;\n        }\n        case \"ObjectSplat\": {\n          const value = await execute(attr.value, scope);\n          value.type === \"object\" && Object.assign(result, value.data);\n          break;\n        }\n        default:\n          throw new Error(`Unknown node type: ${attrType}`);\n      }\n    }\n    return fromJS(result);\n  },\n  Array({ elements }, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope);\n        if (element.isSplat) {\n          if (value.isArray())\n            for await (const v of value)\n              yield v;\n        } else\n          yield value;\n      }\n    });\n  },\n  Tuple() {\n    throw new Error(\"tuples can not be evaluated\");\n  },\n  async Or({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n    return leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE;\n  },\n  async And({ left, right }, scope, execute) {\n    const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n    return leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE;\n  },\n  async Not({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE;\n  },\n  Neg({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data));\n  },\n  Pos({ base }, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data));\n  },\n  Asc() {\n    return NULL_VALUE;\n  },\n  Desc() {\n    return NULL_VALUE;\n  },\n  async ArrayCoerce({ base }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? value : NULL_VALUE;\n  },\n  async Map({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem);\n        yield await execute(expr, newScope);\n      }\n    }) : NULL_VALUE;\n  },\n  async FlatMap({ base, expr }, scope, execute) {\n    const value = await execute(base, scope);\n    return value.isArray() ? new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem), innerValue = await execute(expr, newScope);\n        if (innerValue.isArray())\n          for await (const inner of innerValue)\n            yield inner;\n        else\n          yield innerValue;\n      }\n    }) : NULL_VALUE;\n  }\n};\nfunction evaluateQuery(tree, options = {}) {\n  const root = fromJS(options.root), dataset = fromJS(options.dataset), params = { ...options.params }, scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n      identity: options.identity === void 0 ? \"me\" : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference\n    },\n    null\n  );\n  return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return !0;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return !1;\n      }\n    default:\n      return !1;\n  }\n}\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  { timestamp: /* @__PURE__ */ new Date(0), identity: \"me\", before: null, after: null },\n  null\n);\nfunction tryConstantEvaluate(node) {\n  return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n  if (\"then\" in value)\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\n  return value;\n}\nasync function portableTextContent(value) {\n  if (value.type === \"object\")\n    return blockText(value.data);\n  if (value.isArray()) {\n    const texts = await arrayText(value);\n    if (texts.length > 0)\n      return texts.join(`\n\n`);\n  }\n  return null;\n}\nasync function arrayText(value, result = []) {\n  for await (const block of value)\n    if (block.type === \"object\") {\n      const text = blockText(block.data);\n      text !== null && result.push(text);\n    } else\n      block.isArray() && await arrayText(block, result);\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type != \"string\")\n    return null;\n  const children = obj.children;\n  if (!Array.isArray(children))\n    return null;\n  let result = \"\";\n  for (const child of children)\n    child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n  return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScore(node.left, node.right, scope, execute);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScore(node.args[0], scope, execute), boost = await execute(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = await execute(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n  const text = await execute(left, scope), pattern = await execute(right, scope);\n  let tokens = [], terms = [];\n  if (await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part));\n  }), !await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part));\n  }) || tokens.length === 0 || terms.length === 0)\n    return 0;\n  let score = 0;\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n    score += freq * (BM25k + 1) / (freq + BM25k);\n  }\n  return score;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value)\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n    case \"object\":\n      if (value._ref)\n        return pathSet.has(value._ref);\n      for (const v of Object.values(value))\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n  }\n  return !1;\n}\nfunction countUTF8(str) {\n  let count2 = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    code >= 55296 && code <= 56319 || count2++;\n  }\n  return count2;\n}\nconst _global = {};\n_global.anywhere = async function() {\n  throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope);\n    if (value.type !== \"null\")\n      return value;\n  }\n  return NULL_VALUE;\n};\n_global.count = async function(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (!inner.isArray())\n    return NULL_VALUE;\n  let num = 0;\n  for await (const _ of inner)\n    num++;\n  return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function(args, scope, execute) {\n  const val = await execute(args[0], scope);\n  return val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function(args, scope, execute) {\n  return (await execute(args[0], scope)).type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function(args, scope) {\n  return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  if (inner.type === \"string\")\n    return fromNumber(countUTF8(inner.data));\n  if (inner.isArray()) {\n    let num = 0;\n    for await (const _ of inner)\n      num++;\n    return fromNumber(num);\n  }\n  return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function(args, scope, execute) {\n  const inner = await execute(args[0], scope);\n  return inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  switch (value.type) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"datetime\":\n      return fromString(`${value.data}`);\n    default:\n      return NULL_VALUE;\n  }\n};\n_global.string.arity = 1;\n_global.references = async function(args, scope, execute) {\n  const pathSet = /* @__PURE__ */ new Set();\n  for (const arg of args) {\n    const path2 = await execute(arg, scope);\n    if (path2.type === \"string\")\n      pathSet.add(path2.data);\n    else if (path2.isArray())\n      for await (const elem of path2)\n        elem.type === \"string\" && pathSet.add(elem.data);\n  }\n  if (pathSet.size === 0)\n    return FALSE_VALUE;\n  const scopeValue = await scope.value.get();\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c) => c >= 1;\n_global.round = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  if (value.type !== \"number\")\n    return NULL_VALUE;\n  const num = value.data;\n  let prec = 0;\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope);\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data))\n      return NULL_VALUE;\n    prec = precValue.data;\n  }\n  return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2) => count2 >= 1 && count2 <= 2;\n_global.now = async function(args, scope) {\n  return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function() {\n  throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\")\n    return NULL_VALUE;\n  const sep = await execute(args[1], scope);\n  return sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromJS([]) : sep.data.length === 0 ? fromJS(Array.from(str.data)) : fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n  const str = await execute(args[0], scope);\n  if (str.type !== \"string\")\n    return NULL_VALUE;\n  const prefix = await execute(args[1], scope);\n  return prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  const sep = await execute(args[1], scope);\n  if (sep.type !== \"string\")\n    return NULL_VALUE;\n  let buf = \"\", needSep = !1;\n  for await (const elem of arr) {\n    switch (needSep && (buf += sep.data), elem.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        buf += `${elem.data}`;\n        break;\n      default:\n        return NULL_VALUE;\n    }\n    needSep = !0;\n  }\n  return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  return arr.isArray() ? new StreamValue(async function* () {\n    for await (const elem of arr)\n      elem.type !== \"null\" && (yield elem);\n  }) : NULL_VALUE;\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n  const value = await execute(args[0], scope);\n  return value.isArray() ? new StreamValue(async function* () {\n    const added = /* @__PURE__ */ new Set();\n    for await (const iter of value)\n      switch (iter.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          added.has(iter.data) || (added.add(iter.data), yield iter);\n          break;\n        default:\n          yield iter;\n      }\n  }) : NULL_VALUE;\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n  const value = await execute(args[0], scope), text = await portableTextContent(value);\n  return text === null ? NULL_VALUE : fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n  return scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n  return scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function(base, args, scope, execute) {\n  if (await !0, !base.isArray())\n    return NULL_VALUE;\n  const mappers = [], directions = [];\n  let n = 0;\n  for (let mapper of args) {\n    let direction = \"asc\";\n    mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction), n++;\n  }\n  const aux = [];\n  let idx = 0;\n  for await (const value of base) {\n    const newScope = scope.createNested(value), tuple = [await value.get(), idx];\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope);\n      tuple.push(await result.get());\n    }\n    aux.push(tuple), idx++;\n  }\n  return aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\" && (c = -c), c !== 0)\n        return c;\n    }\n    return aTuple[1] - bTuple[1];\n  }), fromJS(aux.map((v) => v[0]));\n};\npipeFunctions.order.arity = (count2) => count2 >= 1;\npipeFunctions.score = async function(base, args, scope, execute) {\n  if (!base.isArray())\n    return NULL_VALUE;\n  const unknown = [], scored = [];\n  for await (const value of base) {\n    if (value.type !== \"object\") {\n      unknown.push(await value.get());\n      continue;\n    }\n    const newScope = scope.createNested(value);\n    let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n    for (const arg of args)\n      valueScore += await evaluateScore(arg, newScope, execute);\n    const newObject = Object.assign({}, value.data, { _score: valueScore });\n    scored.push(newObject);\n  }\n  return scored.sort((a, b) => b._score - a._score), fromJS(scored);\n};\npipeFunctions.score.arity = (count2) => count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n  const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n  return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n};\ndelta.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = () => {\n  throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      (n === void 0 || elem.data < n) && (n = elem.data);\n    }\n  return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      (n === void 0 || elem.data > n) && (n = elem.data);\n    }\n  return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n = 0;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      n += elem.data;\n    }\n  return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n  const arr = await execute(args[0], scope);\n  if (!arr.isArray())\n    return NULL_VALUE;\n  let n = 0, c = 0;\n  for await (const elem of arr)\n    if (elem.type !== \"null\") {\n      if (elem.type !== \"number\")\n        return NULL_VALUE;\n      n += elem.data, c++;\n    }\n  return c === 0 ? NULL_VALUE : fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function(args, scope, execute) {\n  return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n  global: _global,\n  string: string2,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime: dateTime2\n};\nvar __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => (__defNormalProp$1(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass MarkProcessor {\n  constructor(string, marks, parseOptions) {\n    __publicField$1(this, \"string\"), __publicField$1(this, \"marks\"), __publicField$1(this, \"index\"), __publicField$1(this, \"parseOptions\"), __publicField$1(this, \"allowBoost\", !1), this.string = string, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func)\n      throw new Error(`Unknown handler: ${mark.name}`);\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    return this.shift(), this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n    return this.shift(), this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), { type: \"error\", position: pos }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos, token = str[pos], marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === \"error\")\n        return rhs;\n      switch (pos = skipWS(str, rhs.position), str[pos]) {\n        case \",\": {\n          for (marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks), pos = skipWS(str, pos + 1); ; ) {\n            if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\")\n              return rhs;\n            if (pos = skipWS(str, rhs.position), str[pos] !== \",\")\n              break;\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== \")\")\n            return { type: \"error\", position: pos };\n          pos++, marks.push({ name: \"tuple_end\", position: pos });\n          break;\n        }\n        case \")\": {\n          pos++, marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n          break;\n        }\n        default:\n          return { type: \"error\", position: pos };\n      }\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\")\n        return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"[\":\n      if (marks = [{ name: \"array\", position: pos }], pos = skipWS(str, pos + 1), str[pos] !== \"]\")\n        for (; ; ) {\n          str.slice(pos, pos + 3) === \"...\" && (marks.push({ name: \"array_splat\", position: pos }), pos = skipWS(str, pos + 3));\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\")\n            return res;\n          if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\"))\n            break;\n        }\n      if (str[pos] === \"]\")\n        pos++, marks.push({ name: \"array_end\", position: pos });\n      else\n        return { type: \"error\", position: pos };\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\")\n        return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"^\": {\n      for (pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\"; )\n        marks.push({ name: \"dblparent\", position: startPos }), pos += 2;\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }], pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }], pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      identLen && (pos += 1 + identLen, marks = [\n        { name: \"param\", position: startPos },\n        { name: \"ident\", position: startPos + 1 },\n        { name: \"ident_end\", position: pos }\n      ]);\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          fracLen && (name = \"float\", pos += 1 + fracLen);\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen)\n            return { type: \"error\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        switch (pos += identLen, str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\")\n              return result;\n            marks = result.marks, pos = result.position;\n            break;\n          }\n          default:\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n        }\n        break;\n      }\n    }\n  }\n  if (!marks)\n    return { type: \"error\", position: pos };\n  let lhsLevel = 12, trav;\n  loop:\n    for (; ; ) {\n      let innerPos = skipWS(str, pos);\n      if (innerPos === str.length) {\n        pos = innerPos;\n        break;\n      }\n      if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n        for (marks.unshift({ name: \"traverse\", position: startPos }); trav.type === \"success\"; )\n          marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n        marks.push({ name: \"traversal_end\", position: pos });\n        continue;\n      }\n      switch (str[innerPos]) {\n        case \"=\": {\n          switch (str[innerPos + 1]) {\n            case \">\": {\n              if (level > 1 || lhsLevel <= 1)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks = marks.concat(rhs.marks), marks.unshift({ name: \"pair\", position: startPos }), pos = rhs.position, lhsLevel = 1;\n              break;\n            }\n            case \"=\": {\n              if (level > 4 || lhsLevel <= 4)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n              break;\n            }\n            default:\n              break loop;\n          }\n          break;\n        }\n        case \"+\": {\n          if (level > 6 || lhsLevel < 6)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"add\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n          break;\n        }\n        case \"-\": {\n          if (level > 6 || lhsLevel < 6)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"sub\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n          break;\n        }\n        case \"*\": {\n          if (str[innerPos + 1] === \"*\") {\n            if (level > 8 || lhsLevel <= 8)\n              break loop;\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n            if (rhs2.type === \"error\")\n              return rhs2;\n            marks = marks.concat(rhs2.marks), marks.unshift({ name: \"pow\", position: startPos }), pos = rhs2.position, lhsLevel = 8;\n            break;\n          }\n          if (level > 7 || lhsLevel < 7)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"mul\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n          break;\n        }\n        case \"/\": {\n          if (level > 7 || lhsLevel < 7)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"div\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n          break;\n        }\n        case \"%\": {\n          if (level > 7 || lhsLevel < 7)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"mod\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n          break;\n        }\n        case \"<\":\n        case \">\": {\n          if (level > 4 || lhsLevel <= 4)\n            break loop;\n          let nextPos = innerPos + 1;\n          str[nextPos] === \"=\" && nextPos++;\n          let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n          break;\n        }\n        case \"|\": {\n          if (str[innerPos + 1] === \"|\") {\n            if (level > 2 || lhsLevel < 2)\n              break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n            if (rhs.type === \"error\")\n              return rhs;\n            marks = marks.concat(rhs.marks), marks.unshift({ name: \"or\", position: startPos }), pos = rhs.position, lhsLevel = 2;\n          } else {\n            if (level > 11 || lhsLevel < 11)\n              break loop;\n            let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n            if (!identLen)\n              return { type: \"error\", position: identPos };\n            if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n              let result = parseFuncCall(str, identPos, pos);\n              if (result.type === \"error\")\n                return result;\n              marks = marks.concat(result.marks), marks.unshift({ name: \"pipecall\", position: startPos }), pos = result.position, lhsLevel = 11;\n            }\n          }\n          break;\n        }\n        case \"&\": {\n          if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"and\", position: startPos }), pos = rhs.position, lhsLevel = 3;\n          break;\n        }\n        case \"!\": {\n          if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4)\n            break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n          if (rhs.type === \"error\")\n            return rhs;\n          marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n          break;\n        }\n        case \"d\": {\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4)\n            break loop;\n          marks.unshift({ name: \"desc\", position: startPos }), pos = innerPos + 4, lhsLevel = 4;\n          break;\n        }\n        case \"a\": {\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4)\n            break loop;\n          marks.unshift({ name: \"asc\", position: startPos }), pos = innerPos + 3, lhsLevel = 4;\n          break;\n        }\n        default:\n          switch (parseRegexStr(str, innerPos, IDENT)) {\n            case \"in\": {\n              if (level > 4 || lhsLevel <= 4)\n                break loop;\n              pos = skipWS(str, innerPos + 2);\n              let isGroup = !1;\n              str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n              let rangePos = pos, result = parseExpr(str, pos, 5);\n              if (result.type === \"error\")\n                return result;\n              if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                let type = \"inc_range\";\n                str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n                let rhs = parseExpr(str, pos, 5);\n                if (rhs.type === \"error\")\n                  return rhs;\n                marks.unshift({ name: \"in_range\", position: startPos }), marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks), pos = rhs.position;\n              } else\n                marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(result.marks);\n              if (isGroup) {\n                if (pos = skipWS(str, pos), str[pos] !== \")\")\n                  return { type: \"error\", position: pos };\n                pos++;\n              }\n              lhsLevel = 4;\n              break;\n            }\n            case \"match\": {\n              if (level > 4 || lhsLevel <= 4)\n                break loop;\n              let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n              if (rhs.type === \"error\")\n                return rhs;\n              marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n              break;\n            }\n            default:\n              break loop;\n          }\n      }\n    }\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n      return identLen2 ? (pos += identLen2, {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      }) : { type: \"error\", position: pos };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n      return identLen && (pos = identPos + identLen, marks.push(\n        { name: \"deref_attr\", position: identPos },\n        { name: \"ident\", position: identPos },\n        { name: \"ident_end\", position: pos }\n      )), {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"]\")\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      let rangePos = pos, result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? { type: \"error\", position: pos } : {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        });\n      }\n      return str[pos] !== \"]\" ? { type: \"error\", position: pos } : {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n    }\n  }\n  return { type: \"error\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  if (marks.push({ name: \"func_call\", position: startPos }), str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos }), marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen)\n      return { type: \"error\", position: pos };\n    if (marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\")\n      return { type: \"error\", position: pos };\n    pos++, pos = skipWS(str, pos);\n  } else\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 1);\n  let lastPos = pos;\n  if (str[pos] !== \")\")\n    for (; ; ) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\")\n        return result;\n      if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\"))\n        break;\n    }\n  return str[pos] !== \")\" ? { type: \"error\", position: pos } : (marks.push({ name: \"func_args_end\", position: lastPos }), {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  });\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  for (pos = skipWS(str, pos + 1); str[pos] !== \"}\"; ) {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\")\n      if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\")\n          return expr;\n        marks.push({ name: \"object_splat\", position: pairPos }), marks = marks.concat(expr.marks), pos = expr.position;\n      } else\n        marks.push({ name: \"object_splat_this\", position: pairPos });\n    else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\")\n        return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\")\n          return value;\n        marks.push({ name: \"object_pair\", position: pairPos }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n      } else\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks), pos = expr.position;\n    }\n    if (pos = skipWS(str, pos), str[pos] !== \",\")\n      break;\n    pos = skipWS(str, pos + 1);\n  }\n  return str[pos] !== \"}\" ? { type: \"error\", position: pos } : (pos++, marks.push({ name: \"object_end\", position: pos }), { type: \"success\", marks, position: pos });\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str:\n    for (; ; pos++) {\n      if (pos > str.length)\n        return { type: \"error\", position: pos };\n      switch (str[pos]) {\n        case token: {\n          marks.push({ name: \"str_end\", position: pos }), pos++;\n          break str;\n        }\n        case \"\\\\\":\n          marks.push({ name: \"str_pause\", position: pos }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({ name: \"unicode_hex\", position: pos + 3 }), pos = str.indexOf(\"}\", pos + 3), marks.push({ name: \"unicode_hex_end\", position: pos })) : (marks.push({ name: \"unicode_hex\", position: pos + 2 }), marks.push({ name: \"unicode_hex_end\", position: pos + 6 }), pos += 5) : (marks.push({ name: \"single_escape\", position: pos + 1 }), pos += 1), marks.push({ name: \"str_start\", position: pos + 1 });\n      }\n    }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right)\n    return {\n      type: \"a-a\",\n      build\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right)\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nvar __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: `\n`,\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  constructor() {\n    super(...arguments), __publicField(this, \"name\", \"GroqQueryError\");\n  }\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    return {\n      type: \"Group\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    return {\n      type: \"Parent\",\n      n: p.process(EXPR_BUILDER).n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER), traversalList = [];\n    for (; p.getMark().name !== \"traversal_end\"; )\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--)\n      traversal = traversalList[i](traversal);\n    if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val) => val, traversal)), traversal === null)\n      throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    return name === \"null\" ? { type: \"Value\", value: null } : name === \"true\" ? { type: \"Value\", value: !0 } : name === \"false\" ? { type: \"Value\", value: !1 } : {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    return {\n      type: \"Neg\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  pos(p) {\n    return {\n      type: \"Pos\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop:\n      for (; p.hasMark(); ) {\n        const mark = p.getMark();\n        switch (mark.name) {\n          case \"str_end\":\n            value += p.processStringEnd();\n            break loop;\n          case \"str_pause\":\n            value += p.processStringEnd();\n            break;\n          case \"str_start\":\n            p.shift();\n            break;\n          case \"single_escape\": {\n            const char = p.slice(1);\n            p.shift(), value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n          case \"unicode_hex\":\n            p.shift(), value += expandHex(p.processStringEnd());\n            break;\n          default:\n            throw new Error(`unexpected mark: ${mark.name}`);\n        }\n      }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    for (; p.getMark().name !== \"object_end\"; )\n      attributes.push(p.process(OBJECT_BUILDER));\n    return p.shift(), {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    for (; p.getMark().name !== \"array_end\"; ) {\n      let isSplat = !1;\n      p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    return p.shift(), {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    for (; p.getMark().name !== \"tuple_end\"; )\n      members.push(p.process(EXPR_BUILDER));\n    return p.shift(), {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      for (; p.getMark().name !== \"func_args_end\"; )\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback)\n            throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback)\n            throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      return p.shift(), result;\n    }\n    const args = [];\n    for (; p.getMark().name !== \"func_args_end\"; )\n      argumentShouldBeSelector(namespace, name, args.length) ? (p.process(SELECTOR_BUILDER), args.push({ type: \"Selector\" })) : args.push(p.process(EXPR_BUILDER));\n    if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\")\n      return {\n        type: \"Context\",\n        key: name\n      };\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs)\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const func = funcs[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    return {\n      type: \"FuncCall\",\n      func,\n      namespace,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\")\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n    for (name === \"score\" && (p.allowBoost = !0); ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\")\n        break;\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift(), args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift(), args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift(), p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\n    return func.arity && validateArity(name, func.arity, args.length), {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair(p) {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    return {\n      type: \"Not\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  asc(p) {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc(p) {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n      type: \"Value\",\n      value: p.parseOptions.params[name]\n    } : {\n      type: \"Parameter\",\n      name\n    };\n  }\n}, OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\")\n      throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    return {\n      type: \"ObjectSplat\",\n      value: p.process(EXPR_BUILDER)\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n}, TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n    return value && value.type === \"number\" ? (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right) : value && value.type === \"string\" ? (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right) : (right) => traverseArray(\n      (base) => ({\n        type: \"Filter\",\n        base,\n        expr\n      }),\n      right\n    );\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\")\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    return (rhs) => traverseArray(\n      (base) => ({\n        type: \"Slice\",\n        base,\n        left: leftValue.data,\n        right: rightValue.data,\n        isInclusive\n      }),\n      rhs\n    );\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain(\n      (base) => wrap({\n        type: \"Deref\",\n        base\n      }),\n      right\n    );\n  },\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n}, SELECTOR_BUILDER = {\n  group(p) {\n    return p.process(SELECTOR_BUILDER), null;\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    for (p.process(SELECTOR_BUILDER); p.getMark().name !== \"traversal_end\"; )\n      p.process(TRAVERSE_BUILDER);\n    return p.shift(), null;\n  },\n  this_attr(p) {\n    return p.processString(), null;\n  },\n  neg(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1)\n      return null;\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc(p) {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param(p) {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base)\n    return node.name;\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\")\n    return extractPropertyKey(node.base);\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity == \"number\") {\n    if (count !== arity)\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      );\n  } else if (arity && !arity(count))\n    throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  constructor(position) {\n    super(`Syntax error in GROQ query at position ${position}`), __publicField(this, \"position\"), __publicField(this, \"name\", \"GroqSyntaxError\"), this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\")\n    throw new GroqSyntaxError(result.position);\n  return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\n\n//# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx1SEFBdUgsdURBQXVEO0FBQzlLO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsdURBQXVEO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBCQUEwQixPQUFPLEtBQUssR0FBRyxNQUFNLEdBQUcsSUFBSSxHQUFHLEtBQUssR0FBRyxPQUFPLEdBQUcsT0FBTyxFQUFFLGlCQUFpQjtBQUNySjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUEyQjtBQUNwQyxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBLHVIQUF1SCx1REFBdUQ7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHLDJEQUEyRCxHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQW9EO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxH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bEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBLGlIQUFpSCx1REFBdUQ7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxX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QU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbnlpaXNpLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLm1qcz9hOWI1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDUgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDUob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDUgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5mdW5jdGlvbiBwYXRoUmVnRXhwKHBhdHRlcm4pIHtcbiAgY29uc3QgcmUgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4uc3BsaXQoXCIuXCIpKVxuICAgIHBhcnQgPT09IFwiKlwiID8gcmUucHVzaChcIlteLl0rXCIpIDogcGFydCA9PT0gXCIqKlwiID8gcmUucHVzaChcIi4qXCIpIDogcmUucHVzaChlc2NhcGVSZWdFeHAocGFydCkpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmUuam9pbihcIi5cIil9JGApO1xufVxuY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuXCIpLCBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuUmVcIiksIHRoaXMucGF0dGVybiA9IHBhdHRlcm4sIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgfVxuICBtYXRjaGVzKHN0cikge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm5SZS50ZXN0KHN0cik7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gIH1cbn1cbnZhciBfX2RlZlByb3AkNCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDQob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDQob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidHlwZVwiLCBcInN0cmVhbVwiKSwgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiZ2VuZXJhdG9yXCIpLCBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJ0aWNrZXJcIiksIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImlzRG9uZVwiKSwgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiZGF0YVwiKSwgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3IsIHRoaXMudGlja2VyID0gbnVsbCwgdGhpcy5pc0RvbmUgPSAhMSwgdGhpcy5kYXRhID0gW107XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcylcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICBpZiAodGhpcy5pc0RvbmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpXG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH0sIHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKSwgc2V0dXBUaWNrZXIoKTtcbiAgICB9LCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSlcbiAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpLCB0aWNrKCk7XG4gICAgICB0aGlzLmlzRG9uZSA9ICEwLCB0aWNrKCk7XG4gICAgfTtcbiAgICByZXR1cm4gc2V0dXBUaWNrZXIoKSwgZmV0Y2goKSwgdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNvbnN0IFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gIHJldHVybiBSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSA/IG5ldyBEYXRlKHN0cikgOiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpLCBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpLCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMiksIGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpLCBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMiksIHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBjb25zdCBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gbWlsbGlzICE9IDAgJiYgKGZyYWN0aW9uYWxTZWNvbmQgPSBgLiR7YWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKX1gKSwgYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kfSR7ZnJhY3Rpb25hbFNlY29uZH1aYDtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSwgdGFyZ2V0TGVuZ3RoKSB7XG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgZm9yICg7IHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGg7IClcbiAgICBzdHIgPSBgMCR7c3RyfWA7XG4gIHJldHVybiBzdHI7XG59XG52YXIgX19kZWZQcm9wJDMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQzID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQzKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQzID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gKF9fZGVmTm9ybWFsUHJvcCQzKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpLCB2YWx1ZSk7XG5jbGFzcyBTdGF0aWNWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJkYXRhXCIpLCBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJ0eXBlXCIpLCB0aGlzLmRhdGEgPSBkYXRhLCB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJhcnJheVwiO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSlcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpXG4gICAgICAgICAgeWllbGQgZnJvbUpTKGVsZW1lbnQpO1xuICAgICAgfSh0aGlzLmRhdGEpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGl0ZXJhdGUgb3ZlcjogJHt0aGlzLnR5cGV9YCk7XG4gIH1cbn1cbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpLCBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKCEwLCBcImJvb2xlYW5cIiksIEZBTFNFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKCExLCBcImJvb2xlYW5cIik7XG5jbGFzcyBEYXRlVGltZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJkYXRlXCIpLCB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIHJldHVybiBkYXRlID8gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKSA6IE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgcmV0dXJuIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpLCBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobnVtKSA/IG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpIDogTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgcmV0dXJuIGlzSXRlcmF0b3IodmFsKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKVxuICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgfSkgOiB2YWwgPT0gbnVsbCA/IE5VTExfVkFMVUUgOiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID4gXCJ1XCIgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBcImFycmF5XCIgOiBkYXRhIGluc3RhbmNlb2YgUGF0aCA/IFwicGF0aFwiIDogZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lID8gXCJkYXRldGltZVwiIDogdHlwZW9mIGRhdGE7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiID8gYS5kYXRhID09PSBiLmRhdGEgOiBhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGEuZGF0YS5lcXVhbHMoYi5kYXRhKSA6ICExO1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZywgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZywgTUFYX1RFUk1fTEVOR1RIID0gMTAyNDtcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIHJldHVybiB0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCA/ICExIDogcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQpIHtcbiAgcmV0dXJuIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpLm1hcCgocmUpID0+ICh0b2tlbnMpID0+IHRva2Vucy5zb21lKCh0b2tlbikgPT4gcmUudGVzdCh0b2tlbikpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgcmV0dXJuICh0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW10pLm1hcChcbiAgICAodGVybSkgPT4gbmV3IFJlZ0V4cChgXiR7dGVybS5zbGljZSgwLCBNQVhfVEVSTV9MRU5HVEgpLnJlcGxhY2UoL1xcKi9nLCBcIi4qXCIpfSRgLCBcImlcIilcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBjYih2YWx1ZS5kYXRhKSwgITA7XG4gIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBsZXQgc3VjY2VzcyA9ICEwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB2YWx1ZSlcbiAgICAgIHBhcnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGNiKHBhcnQuZGF0YSkgOiBzdWNjZXNzID0gITE7XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuY29uc3QgVFlQRV9PUkRFUiA9IHtcbiAgZGF0ZXRpbWU6IDEsXG4gIG51bWJlcjogMixcbiAgc3RyaW5nOiAzLFxuICBib29sZWFuOiA0XG59O1xuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSksIGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgaWYgKGFUeXBlICE9PSBiVHlwZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvdGFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKSwgYlR5cGUgPSBnZXRUeXBlKGIpLCBhVHlwZU9yZGVyID0gVFlQRV9PUkRFUlthVHlwZV0gfHwgMTAwLCBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xuICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcilcbiAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gIGxldCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCAmJiAocmVzdWx0ID0gMCksIHJlc3VsdDtcbn1cbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgXCI9PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIhPVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgXCI+XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPFwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBhc3luYyBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIilcbiAgICAgIHJldHVybiBsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgaWYgKHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KVxuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSlcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGxldCB0b2tlbnMgPSBbXSwgcGF0dGVybnMgPSBbXTtcbiAgICByZXR1cm4gYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4ge1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICB9KSwgYXdhaXQgZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pICYmIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIrXCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIiA/IGZyb21KUyh7IC4uLmxlZnQuZGF0YSwgLi4ucmlnaHQuZGF0YSB9KSA6IGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIiA/IGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKSA6IGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgbGVmdClcbiAgICAgICAgeWllbGQgdmFsO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiLVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCIqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAqIGIpLFxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcbiAgXCIqKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKVxufTtcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gKF9fZGVmTm9ybWFsUHJvcCQyKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpLCB2YWx1ZSk7XG5jbGFzcyBTY29wZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwicGFyYW1zXCIpLCBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJzb3VyY2VcIiksIF9fcHVibGljRmllbGQkMih0aGlzLCBcInZhbHVlXCIpLCBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwYXJlbnRcIiksIF9fcHVibGljRmllbGQkMih0aGlzLCBcImNvbnRleHRcIiksIF9fcHVibGljRmllbGQkMih0aGlzLCBcImlzSGlkZGVuXCIsICExKSwgdGhpcy5wYXJhbXMgPSBwYXJhbXMsIHRoaXMuc291cmNlID0gc291cmNlLCB0aGlzLnZhbHVlID0gdmFsdWUsIHRoaXMuY29udGV4dCA9IGNvbnRleHQsIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpIDogbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNIaWRkZW4gPSAhMCwgcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSA9IGV2YWx1YXRlKSB7XG4gIGNvbnN0IGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcbiAgcmV0dXJuIGZ1bmMobm9kZSwgc2NvcGUsIGV4ZWN1dGUpO1xufVxuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcbiAgcmV0dXJuIFwidGhlblwiIGluIHZhbHVlID8gdmFsdWUudGhlbihjYikgOiBjYih2YWx1ZSk7XG59XG5jb25zdCBFWEVDVVRPUlMgPSB7XG4gIFRoaXMoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gIH0sXG4gIFNlbGVjdG9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdG9ycyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSxcbiAgRXZlcnl0aGluZyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS5zb3VyY2U7XG4gIH0sXG4gIFBhcmFtZXRlcih7IG5hbWUgfSwgc2NvcGUpIHtcbiAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gIH0sXG4gIENvbnRleHQoeyBrZXkgfSwgc2NvcGUpIHtcbiAgICBpZiAoa2V5ID09PSBcImJlZm9yZVwiIHx8IGtleSA9PT0gXCJhZnRlclwiKVxuICAgICAgcmV0dXJuIHNjb3BlLmNvbnRleHRba2V5XSB8fCBOVUxMX1ZBTFVFO1xuICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBjb250ZXh0IGtleTogJHtrZXl9YCk7XG4gIH0sXG4gIFBhcmVudCh7IG4gfSwgc2NvcGUpIHtcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XG4gIH0sXG4gIE9wQ2FsbCh7IG9wLCBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcH1gKTtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICByZXR1cm4gXCJ0aGVuXCIgaW4gbGVmdFZhbHVlIHx8IFwidGhlblwiIGluIHJpZ2h0VmFsdWUgPyAoYXN5bmMgKCkgPT4gZnVuYyhhd2FpdCBsZWZ0VmFsdWUsIGF3YWl0IHJpZ2h0VmFsdWUpKSgpIDogZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICB9LFxuICBhc3luYyBTZWxlY3QoeyBhbHRlcm5hdGl2ZXMsIGZhbGxiYWNrIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09ICEwKVxuICAgICAgICByZXR1cm4gZXhlY3V0ZShhbHQudmFsdWUsIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrID8gZXhlY3V0ZShmYWxsYmFjaywgc2NvcGUpIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgSW5SYW5nZSh7IGJhc2UsIGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSksIGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpLCBsZWZ0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IGxlZnRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKGxlZnRDbXAgPT09IG51bGwpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByaWdodENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCByaWdodFZhbHVlLmdldCgpKTtcbiAgICByZXR1cm4gcmlnaHRDbXAgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogaXNJbmNsdXNpdmUgPyBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRSA6IGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEZpbHRlcih7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gYmFzZVZhbHVlLmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGJhc2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChlbGVtKSwgZXhwclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGV4cHJWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBleHByVmFsdWUuZGF0YSA9PT0gITAgJiYgKHlpZWxkIGVsZW0pO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgUHJvamVjdGlvbih7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgIHJldHVybiBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgfSxcbiAgRnVuY0NhbGwoeyBmdW5jLCBhcmdzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIGZ1bmMoYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBQaXBlRnVuY0NhbGwoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIGZ1bmMoYmFzZVZhbHVlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0F0dHJpYnV0ZSh7IGJhc2UsIG5hbWUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQgdmFsdWUgPSBzY29wZS52YWx1ZTtcbiAgICByZXR1cm4gYmFzZSAmJiAodmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKSksIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0VsZW1lbnQoeyBiYXNlLCBpbmRleCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSlcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCksIGZpbmFsSW5kZXggPSBpbmRleCA8IDAgPyBpbmRleCArIGRhdGEubGVuZ3RoIDogaW5kZXg7XG4gICAgcmV0dXJuIGZyb21KUyhkYXRhW2ZpbmFsSW5kZXhdKTtcbiAgfSxcbiAgYXN5bmMgU2xpY2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBhcnJheTIgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0LCByaWdodElkeCA9IHJpZ2h0O1xuICAgIHJldHVybiBsZWZ0SWR4IDwgMCAmJiAobGVmdElkeCA9IGFycmF5Mi5sZW5ndGggKyBsZWZ0SWR4KSwgcmlnaHRJZHggPCAwICYmIChyaWdodElkeCA9IGFycmF5Mi5sZW5ndGggKyByaWdodElkeCksIGlzSW5jbHVzaXZlICYmIHJpZ2h0SWR4KyssIGxlZnRJZHggPCAwICYmIChsZWZ0SWR4ID0gMCksIHJpZ2h0SWR4IDwgMCAmJiAocmlnaHRJZHggPSAwKSwgZnJvbUpTKGFycmF5Mi5zbGljZShsZWZ0SWR4LCByaWdodElkeCkpO1xuICB9LFxuICBhc3luYyBEZXJlZih7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSB8fCB2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XG4gICAgaWYgKHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgaWYgKHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UpXG4gICAgICByZXR1cm4gZnJvbUpTKGF3YWl0IHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UoeyBfcmVmOiBpZCB9KSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKVxuICAgICAgaWYgKGRvYy50eXBlID09PSBcIm9iamVjdFwiICYmIGlkID09PSBkb2MuZGF0YS5faWQpXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIFZhbHVlKHsgdmFsdWUgfSkge1xuICAgIHJldHVybiBmcm9tSlModmFsdWUpO1xuICB9LFxuICBHcm91cCh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gIH0sXG4gIGFzeW5jIE9iamVjdCh7IGF0dHJpYnV0ZXMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0clR5cGUgPSBhdHRyLnR5cGU7XG4gICAgICBzd2l0Y2ggKGF0dHIudHlwZSkge1xuICAgICAgICBjYXNlIFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgcmVzdWx0W2F0dHIubmFtZV0gPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XG4gICAgICAgICAgY29uc3QgY29uZCA9IGF3YWl0IGV4ZWN1dGUoYXR0ci5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09ICExKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0U3BsYXRcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiAke2F0dHJUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKHJlc3VsdCk7XG4gIH0sXG4gIEFycmF5KHsgZWxlbWVudHMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgdmFsdWUpXG4gICAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBUdXBsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIGFzeW5jIE9yKHsgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICByZXR1cm4gbGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGxlZnRWYWx1ZS5kYXRhID09PSAhMCB8fCByaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJpZ2h0VmFsdWUuZGF0YSA9PT0gITAgPyBUUlVFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFuZCh7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITEgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICExID8gRkFMU0VfVkFMVUUgOiBsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiA/IE5VTExfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBOb3QoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgTmVnKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcigtdmFsdWUuZGF0YSkpO1xuICB9LFxuICBQb3MoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksICh2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKHZhbHVlLmRhdGEpKTtcbiAgfSxcbiAgQXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBEZXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBcnJheUNvZXJjZSh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcbiAgICAgICAgeWllbGQgYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICB9XG4gICAgfSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGbGF0TWFwKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pLCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSlcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGlubmVyIG9mIGlubmVyVmFsdWUpXG4gICAgICAgICAgICB5aWVsZCBpbm5lcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XG4gICAgICB9XG4gICAgfSkgOiBOVUxMX1ZBTFVFO1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeSh0cmVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgcm9vdCA9IGZyb21KUyhvcHRpb25zLnJvb3QpLCBkYXRhc2V0ID0gZnJvbUpTKG9wdGlvbnMuZGF0YXNldCksIHBhcmFtcyA9IHsgLi4ub3B0aW9ucy5wYXJhbXMgfSwgc2NvcGUgPSBuZXcgU2NvcGUoXG4gICAgcGFyYW1zLFxuICAgIGRhdGFzZXQsXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgICAgZGVyZWZlcmVuY2U6IG9wdGlvbnMuZGVyZWZlcmVuY2VcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gITA7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUoXG4gIHt9LFxuICBOVUxMX1ZBTFVFLFxuICBOVUxMX1ZBTFVFLFxuICB7IHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApLCBpZGVudGl0eTogXCJtZVwiLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sXG4gIG51bGxcbik7XG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkgPyBjb25zdGFudEV2YWx1YXRlKG5vZGUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogY29uc3RhbnQgZXZhbHVhdGUgc2hvdWxkIG5ldmVyIHJldHVybiBhIHByb21pc2VcIik7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGNvbnN0IHRleHRzID0gYXdhaXQgYXJyYXlUZXh0KHZhbHVlKTtcbiAgICBpZiAodGV4dHMubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKGBcblxuYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCA9IFtdKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgdmFsdWUpXG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBibG9ja1RleHQoYmxvY2suZGF0YSk7XG4gICAgICB0ZXh0ICE9PSBudWxsICYmIHJlc3VsdC5wdXNoKHRleHQpO1xuICAgIH0gZWxzZVxuICAgICAgYmxvY2suaXNBcnJheSgpICYmIGF3YWl0IGFycmF5VGV4dChibG9jaywgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJsb2NrVGV4dChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmouX3R5cGUgIT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgIGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PSBcInN0cmluZ1wiICYmIChyZXN1bHQgKz0gY2hpbGQudGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSksIGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICByZXR1cm4gYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCA/IGlubmVyU2NvcmUgKyBib29zdC5kYXRhIDogMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDAgPyAwIDogbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSAhMCA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHBhdHRlcm4gPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gIGxldCB0b2tlbnMgPSBbXSwgdGVybXMgPSBbXTtcbiAgaWYgKGF3YWl0IGdhdGhlclRleHQodGV4dCwgKHBhcnQpID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KSwgIWF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgKHBhcnQpID0+IHtcbiAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XG4gIH0pIHx8IHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICBsZXQgc2NvcmUgPSAwO1xuICBmb3IgKGNvbnN0IHJlIG9mIHRlcm1zKSB7XG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICBzY29yZSArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmU7XG59XG5mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcbiAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKVxuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xuICBsZXQgY291bnQyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5IHx8IGNvdW50MisrO1xuICB9XG4gIHJldHVybiBjb3VudDI7XG59XG5jb25zdCBfZ2xvYmFsID0ge307XG5fZ2xvYmFsLmFueXdoZXJlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5fZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbl9nbG9iYWwuY29hbGVzY2UgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bGxcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFpbm5lci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBudW0gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpXG4gICAgbnVtKys7XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiB2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiID8gdmFsIDogdmFsLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIHJldHVybiAoYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSkpLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChpbm5lci50eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIGlmIChpbm5lci5pc0FycmF5KCkpIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpXG4gICAgICBudW0rKztcbiAgICByZXR1cm4gZnJvbU51bWJlcihudW0pO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbl9nbG9iYWwubGVuZ3RoLmFyaXR5ID0gMTtcbl9nbG9iYWwucGF0aCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBpbm5lci50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21QYXRoKG5ldyBQYXRoKGlubmVyLmRhdGEpKTtcbn07XG5fZ2xvYmFsLnBhdGguYXJpdHkgPSAxO1xuX2dsb2JhbC5zdHJpbmcgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhgJHt2YWx1ZS5kYXRhfWApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxufTtcbl9nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbl9nbG9iYWwucmVmZXJlbmNlcyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHBhdGhTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgcGF0aDIgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmIChwYXRoMi50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgcGF0aFNldC5hZGQocGF0aDIuZGF0YSk7XG4gICAgZWxzZSBpZiAocGF0aDIuaXNBcnJheSgpKVxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHBhdGgyKVxuICAgICAgICBlbGVtLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgfVxuICBpZiAocGF0aFNldC5zaXplID09PSAwKVxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgY29uc3Qgc2NvcGVWYWx1ZSA9IGF3YWl0IHNjb3BlLnZhbHVlLmdldCgpO1xuICByZXR1cm4gaGFzUmVmZXJlbmNlKHNjb3BlVmFsdWUsIHBhdGhTZXQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbl9nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IChjKSA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IG51bSA9IHZhbHVlLmRhdGE7XG4gIGxldCBwcmVjID0gMDtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcHJlY1ZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBwcmVjID0gcHJlY1ZhbHVlLmRhdGE7XG4gIH1cbiAgcmV0dXJuIHByZWMgPT09IDAgPyBudW0gPCAwID8gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSkgOiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSkgOiBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpO1xufTtcbl9nbG9iYWwucm91bmQuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMSAmJiBjb3VudDIgPD0gMjtcbl9nbG9iYWwubm93ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XG59O1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59O1xuX2dsb2JhbC5ib29zdC5hcml0eSA9IDI7XG5jb25zdCBzdHJpbmcyID0ge307XG5zdHJpbmcyLmxvd2VyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvTG93ZXJDYXNlKCkpO1xufTtcbnN0cmluZzIubG93ZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi51cHBlciA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiB2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodmFsdWUuZGF0YS50b1VwcGVyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLnVwcGVyLmFyaXR5ID0gMTtcbnN0cmluZzIuc3BsaXQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBzZXAgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgcmV0dXJuIHNlcC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHN0ci5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21KUyhbXSkgOiBzZXAuZGF0YS5sZW5ndGggPT09IDAgPyBmcm9tSlMoQXJyYXkuZnJvbShzdHIuZGF0YSkpIDogZnJvbUpTKHN0ci5kYXRhLnNwbGl0KHNlcC5kYXRhKSk7XG59O1xuc3RyaW5nMi5zcGxpdC5hcml0eSA9IDI7XG5fZ2xvYmFsLmxvd2VyID0gc3RyaW5nMi5sb3dlcjtcbl9nbG9iYWwudXBwZXIgPSBzdHJpbmcyLnVwcGVyO1xuc3RyaW5nMi5zdGFydHNXaXRoID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3Qgc3RyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmIChzdHIudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgcHJlZml4ID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIHJldHVybiBwcmVmaXgudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBzdHIuZGF0YS5zdGFydHNXaXRoKHByZWZpeC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5zdHJpbmcyLnN0YXJ0c1dpdGguYXJpdHkgPSAyO1xuY29uc3QgYXJyYXkgPSB7fTtcbmFycmF5LmpvaW4gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBhcnIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBzZXAgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgaWYgKHNlcC50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBsZXQgYnVmID0gXCJcIiwgbmVlZFNlcCA9ICExO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgc3dpdGNoIChuZWVkU2VwICYmIChidWYgKz0gc2VwLmRhdGEpLCBlbGVtLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgYnVmICs9IGAke2VsZW0uZGF0YX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuZWVkU2VwID0gITA7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhidWYpO1xufTtcbmFycmF5LmpvaW4uYXJpdHkgPSAyO1xuYXJyYXkuY29tcGFjdCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gYXJyLmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgICBlbGVtLnR5cGUgIT09IFwibnVsbFwiICYmICh5aWVsZCBlbGVtKTtcbiAgfSkgOiBOVUxMX1ZBTFVFO1xufTtcbmFycmF5LmNvbXBhY3QuYXJpdHkgPSAxO1xuYXJyYXkudW5pcXVlID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZXIgb2YgdmFsdWUpXG4gICAgICBzd2l0Y2ggKGl0ZXIudHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgICAgYWRkZWQuaGFzKGl0ZXIuZGF0YSkgfHwgKGFkZGVkLmFkZChpdGVyLmRhdGEpLCB5aWVsZCBpdGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB5aWVsZCBpdGVyO1xuICAgICAgfVxuICB9KSA6IE5VTExfVkFMVUU7XG59O1xuYXJyYXkudW5pcXVlLmFyaXR5ID0gMTtcbmNvbnN0IHB0ID0ge307XG5wdC50ZXh0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKSwgdGV4dCA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICByZXR1cm4gdGV4dCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHRleHQpO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3Qgc2FuaXR5ID0ge307XG5zYW5pdHkucHJvamVjdElkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlLmNvbnRleHQuc2FuaXR5ID8gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5wcm9qZWN0SWQpIDogTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBzY29wZS5jb250ZXh0LnNhbml0eSA/IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkuZGF0YXNldCkgOiBOVUxMX1ZBTFVFO1xufTtcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAoYXdhaXQgITAsICFiYXNlLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgbWFwcGVycyA9IFtdLCBkaXJlY3Rpb25zID0gW107XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBtYXBwZXIudHlwZSA9PT0gXCJEZXNjXCIgPyAoZGlyZWN0aW9uID0gXCJkZXNjXCIsIG1hcHBlciA9IG1hcHBlci5iYXNlKSA6IG1hcHBlci50eXBlID09PSBcIkFzY1wiICYmIChtYXBwZXIgPSBtYXBwZXIuYmFzZSksIG1hcHBlcnMucHVzaChtYXBwZXIpLCBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKSwgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpLCB0dXBsZSA9IFthd2FpdCB2YWx1ZS5nZXQoKSwgaWR4XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZShtYXBwZXJzW2ldLCBuZXdTY29wZSk7XG4gICAgICB0dXBsZS5wdXNoKGF3YWl0IHJlc3VsdC5nZXQoKSk7XG4gICAgfVxuICAgIGF1eC5wdXNoKHR1cGxlKSwgaWR4Kys7XG4gIH1cbiAgcmV0dXJuIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIiAmJiAoYyA9IC1jKSwgYyAhPT0gMClcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiBhVHVwbGVbMV0gLSBiVHVwbGVbMV07XG4gIH0pLCBmcm9tSlMoYXV4Lm1hcCgodikgPT4gdlswXSkpO1xufTtcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBhc3luYyBmdW5jdGlvbihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCB1bmtub3duID0gW10sIHNjb3JlZCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT0gXCJudW1iZXJcIiA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKVxuICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpO1xuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlLmRhdGEsIHsgX3Njb3JlOiB2YWx1ZVNjb3JlIH0pO1xuICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKSwgZnJvbUpTKHNjb3JlZCk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xuY29uc3QgZGVsdGEgPSB7fTtcbmRlbHRhLm9wZXJhdGlvbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsLCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIHJldHVybiBoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwidXBkYXRlXCIpIDogaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwiY3JlYXRlXCIpIDogaGFzQmVmb3JlID8gZnJvbVN0cmluZyhcImRlbGV0ZVwiKSA6IE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG47XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSAmJiAobiA9IGVsZW0uZGF0YSk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG47XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSAmJiAobiA9IGVsZW0uZGF0YSk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKVxuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVsbFwiKSB7XG4gICAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIG4gKz0gZWxlbS5kYXRhO1xuICAgIH1cbiAgcmV0dXJuIGZyb21KUyhuKTtcbn07XG5tYXRoLnN1bS5hcml0eSA9IDE7XG5tYXRoLmF2ZyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBuID0gMCwgYyA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgbiArPSBlbGVtLmRhdGEsIGMrKztcbiAgICB9XG4gIHJldHVybiBjID09PSAwID8gTlVMTF9WQUxVRSA6IGZyb21KUyhuIC8gYyk7XG59O1xubWF0aC5hdmcuYXJpdHkgPSAxO1xuY29uc3QgZGF0ZVRpbWUyID0ge307XG5kYXRlVGltZTIubm93ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgcmV0dXJuIGZyb21EYXRlVGltZShuZXcgRGF0ZVRpbWUoc2NvcGUuY29udGV4dC50aW1lc3RhbXApKTtcbn07XG5kYXRlVGltZTIubm93LmFyaXR5ID0gMDtcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgc3RyaW5nOiBzdHJpbmcyLFxuICBhcnJheSxcbiAgcHQsXG4gIGRlbHRhLFxuICBkaWZmLFxuICBzYW5pdHksXG4gIG1hdGgsXG4gIGRhdGVUaW1lOiBkYXRlVGltZTJcbn07XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gKF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpLCB2YWx1ZSk7XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3RyaW5nXCIpLCBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtYXJrc1wiKSwgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaW5kZXhcIiksIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInBhcnNlT3B0aW9uc1wiKSwgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWxsb3dCb29zdFwiLCAhMSksIHRoaXMuc3RyaW5nID0gc3RyaW5nLCB0aGlzLm1hcmtzID0gbWFya3MsIHRoaXMuaW5kZXggPSAwLCB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgfVxuICBoYXNNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICB9XG4gIGdldE1hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHttYXJrLm5hbWV9YCk7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh2aXNpdG9yLCB0aGlzLCBtYXJrKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdLCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgpLCB0aGlzLnN0cmluZy5zbGljZShwcmV2LnBvc2l0aW9uLCBjdXJyLnBvc2l0aW9uKTtcbiAgfVxuICBzbGljZShsZW4pIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIHBvcyArIGxlbik7XG4gIH1cbn1cbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvLCBOVU0gPSAvXlxcZCsvLCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiID8gcmVzdWx0IDogKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHBvcyAhPT0gc3RyLmxlbmd0aCA/IChyZXN1bHQuZmFpbFBvc2l0aW9uICYmIChwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMSksIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0pIDogKGRlbGV0ZSByZXN1bHQucG9zaXRpb24sIGRlbGV0ZSByZXN1bHQuZmFpbFBvc2l0aW9uLCByZXN1bHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zLCB0b2tlbiA9IHN0cltwb3NdLCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgOCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJuZWdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIihcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgc3dpdGNoIChwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgZm9yIChtYXJrcyA9IFt7IG5hbWU6IFwidHVwbGVcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgOyApIHtcbiAgICAgICAgICAgIGlmIChyaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApLCByaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIHBvcysrLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0dXBsZV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiKVwiOiB7XG4gICAgICAgICAgcG9zKyssIG1hcmtzID0gW3sgbmFtZTogXCJncm91cFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiIVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDEwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5vdFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJbXCI6XG4gICAgICBpZiAobWFya3MgPSBbeyBuYW1lOiBcImFycmF5XCIsIHBvc2l0aW9uOiBwb3MgfV0sIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSAhPT0gXCJdXCIpXG4gICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgIHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiICYmIChtYXJrcy5wdXNoKHsgbmFtZTogXCJhcnJheV9zcGxhdFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSk7XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIGlmIChtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpLCBwb3MgPSByZXMucG9zaXRpb24sIHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIixcIiB8fCAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIl1cIikpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJeXCI6IHtcbiAgICAgIGZvciAocG9zKyssIG1hcmtzID0gW107IHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiOyApXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRibHBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyArPSAyO1xuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwicGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQFwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLCBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjoge1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgIGlkZW50TGVuICYmIChwb3MgKz0gMSArIGlkZW50TGVuLCBtYXJrcyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGZyYWNMZW4gJiYgKG5hbWUgPSBcImZsb2F0XCIsIHBvcyArPSAxICsgZnJhY0xlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcImVcIiB8fCBzdHJbcG9zXSA9PT0gXCJFXCIpIHtcbiAgICAgICAgICBuYW1lID0gXCJzY2lcIiwgcG9zKyssIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSAmJiBwb3MrKztcbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IG5hbWUgKyBcIl9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHN3aXRjaCAocG9zICs9IGlkZW50TGVuLCBzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgY2FzZSBcIihcIjoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3MsIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aGlzX2F0dHJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghbWFya3MpXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gIGxldCBsaHNMZXZlbCA9IDEyLCB0cmF2O1xuICBsb29wOlxuICAgIGZvciAoOyA7ICkge1xuICAgICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpLCB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIGZvciAobWFya3MudW5zaGlmdCh7IG5hbWU6IFwidHJhdmVyc2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pOyB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiOyApXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyksIHBvcyA9IHRyYXYucG9zaXRpb24sIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdHJbaW5uZXJQb3NdKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICBzd2l0Y2ggKHN0cltpbm5lclBvcyArIDFdKSB7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IDEgfHwgbGhzTGV2ZWwgPD0gMSlcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgMSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiK1wiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYWRkXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDYgfHwgbGhzTGV2ZWwgPCA2KVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgNyk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIqXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA4IHx8IGxoc0xldmVsIDw9IDgpXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzMiA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDgpO1xuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzMjtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwb3dcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMyLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxldmVsID4gNyB8fCBsaHNMZXZlbCA8IDcpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA4KTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRpdlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNylcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtb2RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgICBzdHJbbmV4dFBvc10gPT09IFwiPVwiICYmIG5leHRQb3MrKztcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyksIDUpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAyIHx8IGxoc0xldmVsIDwgMilcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAzKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwib3JcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSlcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICAgICAgICBpZiAoIWlkZW50TGVuKVxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xuICAgICAgICAgICAgaWYgKHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW4sIHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGlwZWNhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByZXN1bHQucG9zaXRpb24sIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCImXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIgfHwgbGV2ZWwgPiAzIHx8IGxoc0xldmVsIDwgMylcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDQpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiIVwiOiB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSBcIj1cIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImRcIjoge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8IDQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDQsIGxoc0xldmVsID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gXCJhc2NcIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPCA0KVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDMsIGxoc0xldmVsID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAocGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpblwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuICAgICAgICAgICAgICBsZXQgaXNHcm91cCA9ICExO1xuICAgICAgICAgICAgICBzdHJbcG9zXSA9PT0gXCIoXCIgJiYgKGlzR3JvdXAgPSAhMCwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSkpO1xuICAgICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgNSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgICBzdHJbcG9zICsgMl0gPT09IFwiLlwiID8gKHR5cGUgPSBcImV4Y19yYW5nZVwiLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSkgOiBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiaW5fcmFuZ2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIilcIilcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIDUpO1xuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgNSB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBsZXQgZmFpbFBvc2l0aW9uID0gKHRyYXYgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYXYudHlwZSkgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbiB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBsZXQgaWRlbnRTdGFydCA9IHBvcywgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgcmV0dXJuIGlkZW50TGVuMiA/IChwb3MgKz0gaWRlbnRMZW4yLCB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrczogW1xuICAgICAgICAgIHsgbmFtZTogXCJhdHRyX2FjY2Vzc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50U3RhcnQgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9KSA6IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcImRlcmVmXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgIHJldHVybiBpZGVudExlbiAmJiAocG9zID0gaWRlbnRQb3MgKyBpZGVudExlbiwgbWFya3MucHVzaChcbiAgICAgICAgeyBuYW1lOiBcImRlcmVmX2F0dHJcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICkpLCB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrcyxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICBjYXNlIFwiW1wiOiB7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW3sgbmFtZTogXCJhcnJheV9wb3N0Zml4XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgbGV0IHJhbmdlUG9zID0gcG9zLCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICBzdHJbcG9zICsgMl0gPT09IFwiLlwiID8gKHR5cGUgPSBcImV4Y19yYW5nZVwiLCBwb3MgKz0gMykgOiBwb3MgKz0gMiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIHJldHVybiByaHMudHlwZSA9PT0gXCJlcnJvclwiID8gcmhzIDogKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIl1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0gOiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJzbGljZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgIHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH1cbiAgICAgICAgICBdLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyW3Bvc10gIT09IFwiXVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIHx8IHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcmVzdWx0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiB8fCByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcbiAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwibmFtZXNwYWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBwb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbiB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgbmFtZUxlbiksIHN0cltwb3NdICE9PSBcIihcIilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIHBvcysrLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICB9IGVsc2VcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgbGV0IGxhc3RQb3MgPSBwb3M7XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyksIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb24sIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIixcIiB8fCAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIilcIikpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIHN0cltwb3NdICE9PSBcIilcIiA/IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0gOiAobWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19hcmdzX2VuZFwiLCBwb3NpdGlvbjogbGFzdFBvcyB9KSwge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoc3RyLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJvYmplY3RcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgZm9yIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgc3RyW3Bvc10gIT09IFwifVwiOyApIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcbiAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpXG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyksIHN0cltwb3NdICE9PSBcIn1cIiAmJiBzdHJbcG9zXSAhPT0gXCIsXCIpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLCBwb3NpdGlvbjogcGFpclBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcyksIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0X3RoaXNcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3BhaXJcIiwgcG9zaXRpb246IHBhaXJQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKSwgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiBcIm9iamVjdF9leHByXCIsIHBvc2l0aW9uOiBwb3MgfSwgZXhwci5tYXJrcyksIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgfVxuICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICBicmVhaztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICByZXR1cm4gc3RyW3Bvc10gIT09IFwifVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IChwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7IG5hbWU6IFwic3RyXCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHN0cjpcbiAgICBmb3IgKDsgOyBwb3MrKykge1xuICAgICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MrKztcbiAgICAgICAgICBicmVhayBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KSwgc3RyW3BvcyArIDFdID09PSBcInVcIiA/IHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIgPyAobWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSksIHBvcyA9IHN0ci5pbmRleE9mKFwifVwiLCBwb3MgKyAzKSwgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSkpIDogKG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAyIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyArIDYgfSksIHBvcyArPSA1KSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pLCBwb3MgKz0gMSksIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9zdGFydFwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiBiKGEoYmFzZSkpO1xufVxuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcbn1cbmZ1bmN0aW9uIGZsYXRNYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIkZsYXRNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlQXJyYXkoYnVpbGQsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICBidWlsZFxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpLCB2YWx1ZSk7XG5jb25zdCBFU0NBUEVfU0VRVUVOQ0UgPSB7XG4gIFwiJ1wiOiBcIidcIixcbiAgJ1wiJzogJ1wiJyxcbiAgXCJcXFxcXCI6IFwiXFxcXFwiLFxuICBcIi9cIjogXCIvXCIsXG4gIGI6IFwiXFxiXCIsXG4gIGY6IFwiXFxmXCIsXG4gIG46IGBcbmAsXG4gIHI6IFwiXFxyXCIsXG4gIHQ6IFwiXHRcIlxufTtcbmZ1bmN0aW9uIGV4cGFuZEhleChzdHIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufVxuY2xhc3MgR3JvcVF1ZXJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVF1ZXJ5RXJyb3JcIik7XG4gIH1cbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIGlmICgoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpICYmICh0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KCh2YWwpID0+IHZhbCwgdHJhdmVyc2FsKSksIHRyYXZlcnNhbCA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogdW5leHBlY3RlZCBlbXB0eSB0cmF2ZXJzYWxcIik7XG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiBudWxsIH0gOiBuYW1lID09PSBcInRydWVcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITAgfSA6IG5hbWUgPT09IFwiZmFsc2VcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITEgfSA6IHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOZWdcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb3NcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIrXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBzdWIocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi1cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG11bChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIvXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtb2QocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIiVcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxvb3A6XG4gICAgICBmb3IgKDsgcC5oYXNNYXJrKCk7ICkge1xuICAgICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInN0cl9lbmRcIjpcbiAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBjYXNlIFwic3RyX3BhdXNlXCI6XG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJfc3RhcnRcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzaW5nbGVfZXNjYXBlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgICBwLnNoaWZ0KCksIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcms6ICR7bWFyay5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJvYmplY3RfZW5kXCI7IClcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiOyApIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gITE7XG4gICAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIgJiYgKGlzU3BsYXQgPSAhMCwgcC5zaGlmdCgpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCI7IClcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICB9O1xuICAgICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5mYWxsYmFjayA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcC5zaGlmdCgpLCByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCI7IClcbiAgICAgIGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIG5hbWUsIGFyZ3MubGVuZ3RoKSA/IChwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUiksIGFyZ3MucHVzaCh7IHR5cGU6IFwiU2VsZWN0b3JcIiB9KSkgOiBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIGlmIChwLnNoaWZ0KCksIG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiAobmFtZSA9PT0gXCJiZWZvcmVcIiB8fCBuYW1lID09PSBcImFmdGVyXCIpICYmIHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICBrZXk6IG5hbWVcbiAgICAgIH07XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdClcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3RcIik7XG4gICAgY29uc3QgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XG4gICAgaWYgKCFmdW5jcylcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgY29uc3QgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgaWYgKGZ1bmMuYXJpdHkgIT09IHZvaWQgMCAmJiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKSwgZnVuYy5tb2RlICE9PSB2b2lkIDAgJiYgZnVuYy5tb2RlICE9PSBwLnBhcnNlT3B0aW9ucy5tb2RlKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIgJiYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCkpLCBuYW1lc3BhY2UgIT09IFwiZ2xvYmFsXCIpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKSwgYXJncyA9IFtdLCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgIGZvciAobmFtZSA9PT0gXCJzY29yZVwiICYmIChwLmFsbG93Qm9vc3QgPSAhMCk7IDsgKSB7XG4gICAgICBjb25zdCBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICBpZiAobWFya05hbWUgPT09IFwiZnVuY19hcmdzX2VuZFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpLCBhcmdzLnB1c2goeyB0eXBlOiBcIkFzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrTmFtZSA9PT0gXCJkZXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCksIGFyZ3MucHVzaCh7IHR5cGU6IFwiRGVzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpLCBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgIGNvbnN0IGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICByZXR1cm4gZnVuYy5hcml0eSAmJiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKSwge1xuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBbmRcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG9yKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3JcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTm90XCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGFzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhc2NcIik7XG4gIH0sXG4gIGRlc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgZGVzY1wiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gcC5wYXJzZU9wdGlvbnMucGFyYW1zICYmIHAucGFyc2VPcHRpb25zLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBwLnBhcnNlT3B0aW9ucy5wYXJhbXNbbmFtZV1cbiAgICB9IDoge1xuICAgICAgdHlwZTogXCJQYXJhbWV0ZXJcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9XG59LCBPQkpFQ1RfQlVJTERFUiA9IHtcbiAgb2JqZWN0X2V4cHIocCkge1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdF90aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZTogeyB0eXBlOiBcIlRoaXNcIiB9XG4gICAgfTtcbiAgfVxufSwgVFJBVkVSU0VfQlVJTERFUiA9IHtcbiAgc3F1YXJlX2JyYWNrZXQocCkge1xuICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIm51bWJlclwiID8gKHJpZ2h0KSA9PiB0cmF2ZXJzZUVsZW1lbnQoKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzRWxlbWVudFwiLCBiYXNlLCBpbmRleDogdmFsdWUuZGF0YSB9KSwgcmlnaHQpIDogdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIiA/IChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogdmFsdWUuZGF0YSB9KSwgcmlnaHQpIDogKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KFxuICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiRmlsdGVyXCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGV4cHJcbiAgICAgIH0pLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9LFxuICBzbGljZShwKSB7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCksIHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcbiAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgcmV0dXJuIChyaHMpID0+IHRyYXZlcnNlQXJyYXkoXG4gICAgICAoYmFzZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJTbGljZVwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcbiAgICAgICAgaXNJbmNsdXNpdmVcbiAgICAgIH0pLFxuICAgICAgcmhzXG4gICAgKTtcbiAgfSxcbiAgcHJvamVjdGlvbihwKSB7XG4gICAgY29uc3Qgb2JqID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKChiYXNlKSA9PiAoeyB0eXBlOiBcIlByb2plY3Rpb25cIiwgYmFzZSwgZXhwcjogb2JqIH0pLCByaWdodCk7XG4gIH0sXG4gIGF0dHJfYWNjZXNzKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZSB9KSwgcmlnaHQpO1xuICB9LFxuICBkZXJlZihwKSB7XG4gICAgbGV0IGF0dHIgPSBudWxsO1xuICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiICYmIChwLnNoaWZ0KCksIGF0dHIgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3Qgd3JhcCA9IChiYXNlKSA9PiBhdHRyID8geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oXG4gICAgICAoYmFzZSkgPT4gd3JhcCh7XG4gICAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgICAgYmFzZVxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIGFycmF5X3Bvc3RmaXgocCkge1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7IHR5cGU6IFwiQXJyYXlDb2VyY2VcIiwgYmFzZSB9KSwgcmlnaHQpO1xuICB9XG59LCBTRUxFQ1RPUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgcmV0dXJuIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSwgbnVsbDtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgZm9yIChwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiOyApXG4gICAgICBwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUik7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwgbnVsbDtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICByZXR1cm4gcC5wcm9jZXNzU3RyaW5nKCksIG51bGw7XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgIGNvbnN0IGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFpcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFuZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9yKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbm90KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYXNjKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGVzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQWNjZXNzQXR0cmlidXRlXCIgJiYgIW5vZGUuYmFzZSlcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICBpZiAobm9kZS50eXBlID09PSBcIkRlcmVmXCIgfHwgbm9kZS50eXBlID09PSBcIk1hcFwiIHx8IG5vZGUudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNsaWNlXCIgfHwgbm9kZS50eXBlID09PSBcIkZpbHRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5Q29lcmNlXCIpXG4gICAgcmV0dXJuIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlLmJhc2UpO1xuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiAke25vZGUudHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT0gXCJudW1iZXJcIikge1xuICAgIGlmIChjb3VudCAhPT0gYXJpdHkpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXG4gICAgICAgIGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuIEV4cGVjdGVkICR7YXJpdHl9LCBnb3QgJHtjb3VudH0uYFxuICAgICAgKTtcbiAgfSBlbHNlIGlmIChhcml0eSAmJiAhYXJpdHkoY291bnQpKVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLmApO1xufVxuZnVuY3Rpb24gYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgZnVuY3Rpb25OYW1lLCBhcmdDb3VudCkge1xuICBjb25zdCBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMgPSBbXCJjaGFuZ2VkQW55XCIsIFwiY2hhbmdlZE9ubHlcIl07XG4gIHJldHVybiBuYW1lc3BhY2UgPT0gXCJkaWZmXCIgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbmNsYXNzIEdyb3FTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocG9zaXRpb24pIHtcbiAgICBzdXBlcihgU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gJHtwb3NpdGlvbn1gKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uXCIpLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FTeW50YXhFcnJvclwiKSwgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gIHJldHVybiBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKS5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59XG5leHBvcnQge1xuICBEYXRlVGltZSxcbiAgUGF0aCxcbiAgZXZhbHVhdGVRdWVyeSBhcyBldmFsdWF0ZSxcbiAgcGFyc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD0xLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;